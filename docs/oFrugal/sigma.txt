// sigma.txt 0.0.6                  UTF-8                          2024-05-10
//--|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*
//
//                       OBAP ABSTRACTION FUNCTIONS
//                       ===========================
//
//             <https://orcmid.github.io/miser/oFrugal/sigma.txt>
//
//                        HAND-COMPILED sigma(s, M)
//                        -------------------------
//
//       Note: the file at <https://orcmid.github.io/miser/obap/casep.txt>
//       has been tombstoned with continuation in this location.
//
//       The sigma.s M function is introduced in Miser Project Discussion
//       Note #42.  This file demonstrates the manual compilation of the
//       sigma(s, M) Frugalese description into an oFrugal implementation.
//
//       Review the ^casep development for explanation of the basic skeleton,
//       <https://orcmid.github.io/miser/oFrugal/casep.txt>.
//
//       This file is meant to be processable by oFrugal and the final
//       form is not commented out completely.
//
//               1. The Original Definition
//               2. The λ-form Expression
//               3. Handling let Forms
//                  3.1 Ths simple let-form
//                  3.2 Handling multiple let-form expressions
//               4. Handling Conjunction Conditions
//               5. ****** BOILER PLATE BELOW HERE *****
//
//
//  1. THE ORIGINAL DEFINITION
//
//     From <https://github.com/orcmid/miser/discussions/42>
//
//     σ.s M = if M = s
//             then .ARG
//             else if is-individual(M)
//                  then ` M
//                  else if is-enclosure(M)
//                       then let R = σ.s .a M
//                             in if is-enclosure(R)
//                                then ` M
//                                else .e :: R
//                       else let R = σ.s .a M,
//                                S = σ.s .b M
//                             in if is-enclosure(R) ∧ is-enclosure(S)
//                                then ` M
//                                else .c :: R :: S
//
//   2. THE λ-FORM EXPRESSION
//
//      First switch to the oFrugal/Frugalese mixed form that establishes the
//      application of λ-abstraction heuristics.  As we get farther into
//      oFrugal, the Greek letters will be replaced by ^names limited to the
//      Unicode Basic Latin (ISO 646) glyphs and their code points, avoiding
//      dependence on Unicode and UTF-8 in pre-1.0 oFrugal.
//
//     sigma = λ.s ρ.sigmas λ.M
//             if M = s
//             then .ARG
//             else if is-individual(M)
//                  then ` M
//                  else if is-enclosure(M)
//                       then let R = sigmas .a M
//                             in if is-enclosure(R)
//                                then ` M
//                                else .e :: R
//                       else let R = sigmas .a M,
//                                S = sigmas .b M
//                             in if is-enclosure(R) ∧ is-enclosure(S)
//                                then ` M
//                                else .c :: R :: S
//
//   3. HANDLING LET FORMS
//
//   3.1 The Simple let-Form
//
//      The oFrugal idiomatic handling of the form
//
//          let v = T in U
//
//      requires elimination of the literal v from U in this manner:
//
//          (λ.v U) T
//
//      Thus,
//
//          let R = sigmas .a M
//           in if is-enclosure(R)
//                 then ` M
//                 else .e :: R
//
//      becomes
//                                                                      (a)
//          λ.R ( if is-enclosure(R)
//                then ` M
//                else .e :: R
//                  )
//          sigmas .a M
//
//      There is an occurrence of M in the body of the λ.R abstraction.  This
//      leads to the M in ` M having to be inserted every time sigma recurses
//      on operand M, even for all the times is-enclosure(M) does not hold.
//
//      We can delay such deep substitution by abstracting M and applying
//      that result at the level where M is the current operand.
//                                                                      (b)
//         ( ( λ.R if is-enclosure(R)
//                then λ.M ` M
//                else λ.M (.e :: R )
//                )
//           sigmas .a .M
//           )
//          M
//
//      There is now an additional idiom that can be employed.  Since M is
//      already abstracted and is the operand at the time of the outer
//      application ((..)...) M and the ((..)...) returns simple M-abstracted
//      forms.  That allows evaluation directly:
//                                                                      (c)
//         .ev ( ( λ.R if is-enclosure(R)
//                     then λ.M ` M
//                     else λ.M (.e :: R )
//                     )
//                sigmas .a M
//                )
//
//   3.2 Handling Multiple let-Form Expressions
//
//      For the current M being a pair, the operation is
//
//          let R = sigmas .A M,                                        (a)
//              S = sigmas .B M
//           in if is-enclosure(R) ∧ is-enclosure(S)
//              then ` M
//              else .c :: R :: S
//
//      Treat this with the the same device as in (3.1a).
//
//      There is is no benefit to creating a
//
//          ((λ.R λ.S ...) sigmas .A M) sigmas .b M
//
//      since both operands are always going to be supplied.
//
//     The applicative structure can be simplifed by operating on R and S as
//     a pair.
//
//           (λ.RS ...) ( sigmas .a M :: sigmas .b M )
//
//      and reaching the same form as (3.1c):
//                                                                      (b)
//           .ev ( ( λ.RS if is-enclosure(.a RS) ∧ is-enclosure(.b RS)
//                        then λ.M ` M
//                        else λ.M ( .c :: RS )
//                        )
//                 ( sigmas .a M :: sigmas .b M )
//                 )
//
//    4. Handling Conjunction Conditions
//
//       For the conjunction,
//
//                 is-enclosure(a.RS) ∧ is-enclosure(b.RS)              (a)
//
//       the normal interpretation of P ∧ Q for oFrugal is by
//
//                 if P then Q else .b
//
//       where .b is the computational form for P ∧ Q not satisfied.
//
//       This short-circuit determination is valid in oFrugal because there
//       is no side-effect being skirted by failing to evaluate Q when
//       P evaluates to .b.
//
//       In this specific case, P and Q are already determined exactly once
//       each as part of the RS pair, so their is no duplication of effort.
//
//       Expanding conjunction (a) in (3.2b) yields straight oFrugal
//
//       DON'T DO THIS.  EVEN IF CORRECT, IT IS TOO INSCRUTIBLE.  DO THIS
//       BY DEFINING PARTS AND THEN PUTTING IT ALL TOGETHER.
//       ****************************************************************
//
//       (.ev :: ( `( .ev :: ( .d :: (.a :: .arg)                        (b)
//                                :: .b :: .a :: .arg )
//                       ::   `( (.d :: (.b :: .arg)
//                                   :: b :: .b :: .arg )
//                               :: .b )
//                       )
//                  :: `(    `( .e :: .arg)
//                         :: .c :: .arg )
//                 )
//                 :: ( .c :: (.self :: .a :: .arg)
//                         :: .self ::.b :: .arg )
//              )
//
//       with sigmas and M abstracted from this for completeness.
//
//  ****** BOILER PLATE BELOW HERE *** CUSTOMIZATION FOR SIGMA PENDING ****

//--|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*
//
//                   Copyright 2024 Dennis E. Hamilton
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//              http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
//--|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*
//
// ATTRIBUTION
//
//   Hamilton, Dennis E. Hand-compiled sigma(s, M).  Miser Theory Conception
//   text file sigma.txt version 0.0.6 dated 2024-05-10, available on the
//   Internet as a version of
//   <https://orcmid.github.io/miser/oFrugal/sigma.txt>
//
//--|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*
//
// TODO
//
// * Extend handling let-forms to include multiple let forms.
//
// * Refer to the idioms already provided for casep.
//
// * Trim the contents and sections here as they are repurposed/deleted for
//   sigma(s, M).
//
// * The achievement here is the handling of let and then how to deal with
//   global references out of the let form, in this case to references to the
//   global M.  We don't want to stuff M into those.  It will be interesting
//   to see how this can be streamlined.
//
// * Break down into definitions of temporary forms so the combination into
//   the more-complex and unreadable mix of .self and .arg occurrences with
//   no symbols is comprehensible.
//
// * Point out that use of temp intermediate definitions is also part of
//   creating "macros" for building scripts.
//
//--|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*
//
// 0.0.6 2024-05-10T23:50Z Review and prepare to use temporary definitions
//       as a way of remaining comprehensible.
// 0.0.5 2024-05-08T23:39Z Complete hand-compiling of the conjunction case
// 0.0.4 2024-05-08T15:01Z Touch-Ups for printing and review
// 0.0.3 2024-05-07T16:17Z Touch-up and start expanding conjunction handling
// 0.0.2 2024-05-06T21:55Z Introduce listings for multiple let forms
// 0.0.1 2024-05-05T21:16Z Introduce handling single let forms
// 0.0.0 2024-05-05T18:36Z Create placeholder with boilerplate.
//
//                         *** end of sigma.txt ***

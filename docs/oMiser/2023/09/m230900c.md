<!-- m230900c.md 0.0.7              UTF-8                         2026-02-16
     ----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*
     source <https://github.com/orcmid/miser/blob/master/docs/omiser/2023/09/m230900c.md>
     publication <https://orcmid.github.io/miser/omiser/2023/09/m230900c.html>
     -->
<table border="0" width="100%">
  <tr>
    <td width="25%" align="left" height="6">
       <a href="../../" title="The Miser Project on GitHub">
       <img src="../../../images/misertheory-logo.png" /></a>
    </td>
       <td width="48%" height="6"><p align="center"><font color="#990033"><strong>
	<i><a href="../../m000001.htm"><font color="#990033">oMiser Technical Note
    </font></a></i><br />
    <i><big><a href="m230900.htm"><font color="#990033">HashFlag Technique
    </font></a></big></i><br />
    <i><big><big>Ob Comparison</big></big></i></strong></font></p>
    </td>
    <td width="27%" height="6" valign="middle" align="right">
      <b><tt>
      <a href="../../../../" target="_top">orcmid.github.io</a>&gt;
      </tt></b>
      <br />
      <a href="https://clustrmaps.com/site/1bw9w" title="Visit tracker">
            <img src="//www.clustrmaps.com/map_v2.png?d=3-2eQV4fOuelVHp_YtztZ0hl9Uj4ei9zLKw_nRgCgyM&cl=ffffff" />
      </a><br />
      <b>
      <a href="../../../" target="_top">miser</a>&gt;
      <a href="../../" target="_top">oMiser</a>&gt;
      <br />
      <a href="../" target="_top">2023</a>&gt;
      <a href="./" target="_top">09</a>&gt;
      <br /><br />
         <a href="m230900c.html" target="_top">m230900c</a>&gt;</b>
      <br />
      <small><small>
        0.0.7 2026-02-16T23:39Z<!-- MAINTAIN THIS MANUALLY -->
      </small></small>
      </td>
  </tr>
</table>

## 1. What Do HashFlags Have to Do With Comparison?

All ob-cells have a 32-bit HashFlag.  That HashFlag can be used to search for associated information about the ob, such as any symbolic name in the case of
a literal individual (lindy).

The reason that **all** ob-cells have a HashFlag is so that it is easier to
determine whether two different ob-cells are for identical obs or not.  This
serves multiple purposes:

* If the different ob-cells have different HashFlags, they are for immedately
  determined to be for different obs.

* If the HashFlags are the same, then they *might* be for identical
  obs.  If that identity is confirmed, there is potential for removing
  duplicates and saving some storage along with avoiding (prospective)
  subsequent HashFlag collisions.

The conjecture is that HashFlags will at least expedite comparisons between
obs via ob-cells and the improvement is worthwhile.

The prospect of duplicate removal is not so clear and experiments along with instrumentation will determine whether that's a wild-goose chase or not.


## 2. The Abstract Comparison of Obs

In \[[obtheory](https://orcmid.github.io/miser/ob/obtheory.txt): Ob6.
Structural Identity\], the distinction/identity of two obs are in accordance
with 4 conditions.

```text
        u = ob.c(v,w) ∧ z = ob.c(x,y)
                   ⇒ (u = z ⇔ v = x ∧ w = y)                  (a)

        u = ob.e(v) ∧ z = ob.e(x)
                   ⇒ (u = z ⇔ v = x)                          (b)

        ob.is-pair(u) ∧ ob.is-singleton(z)
                   ⇒ u ≠ z                                     (c)

        ob.is-individual(u) ∧ ob.a(z) ≠ z
                   ⇒ u ≠ z                                     (d)
```

This is sufficient to establish all of the cases, where individuals are never
duplicated and are distinguished by their names (and sometimes by their
construction in the case of synthetics introduced as oMiser extensions).


## 3. The Algorithmic Comparison of Obs

The following Frugalese pseudocode constitutes a comparision algorithm for two
ob-cells supplied as operands.

```text
def q(x, y) = if &x = &y                                      // (1)
              then true
              else if is-individual(x) or is-individual(y)
                   then false
                   else if is-enclosure(x) and is-enclosure(y)
                        then q(a(x), a(y))
                        else if is-pair(x) and is-pair(y)
                             then q(a(x), a(y)) and q(b(x), b(y))
                             else false;
```

with the presumption that all ob parameters are assumed passed by reference
and not by value.  Here &*x* is the reference to the ob-cell that was
supplied for parameter *x*.

Procedure q(*x*, *y*) relies on the fact that ob-cells for specific
individuals are never duplicated.  Each distinct individual is manifest by a
single, alwasy-unique ob-cell.


## 4. The Benefit of HashFlags for Expedited Comparison

A valuable feature of HashFlags is that the Flag distinguishes the flavor
of the ob represented by the ob-cell. If the HashFlags are different,
the represented obs must be different.  If the HashFlags agree, the
represented obs are of the same structure.

This leads to useful streamlining:

```sml
def q(x, y) = if &x = &y                                      // (2)
              then true
              else if hashflag(x) ≠ hashflag(y)
                   then false
                   else // they have identical Flags as well as Hashes
                        if is-individual(x)
                        then false // same individual only if same loc
                        else if is-enclosure(x)
                             then q(a(x), a(y))
                             else q(a(x), a(y)) and q(b(x), b(y));
```

The usage of hash codes to quickly distinguish list structures, as in LISP,
was pointed out by Paul McJones.


## 5. The Quest to Eliminate Duplicates

When q(*x*, *y*) determines that two distinct ob-cells manifest the
same obs, it might be valuable to coalesce into one ob-cell in some manner.
That would have a recurrence of the comparison find that *x* and *y* have the
same location and provide a direct result.

It is speculative whether recurrence of a specific comparison is likely. What
follows applies when there is some indication that the additional effort
involved is worthwhile.

To accomplish this, we need to know where the references for *x* and *y* were
obtained.  That is, what were they found in that they could be altered in
order to reduce a duplication?

First, there are ones where we do know where we're coming from: going into
recursive steps q(a(*x*), a(*y*)) and q(b(*x*), b(*y*)) in (2, above).

So let's replace those with qa(*px*, *py*) and qb(*px*, *py*) so we pass in
references to the ob-cells that we're going to check parts of.  We now can
determine which cells the compared a-parts and b-parts are found in.  That is
enough to determine how to coalesce matches of obs in different locations.

In very-pseudo-Frugalese,

```text
def qa(px, py) = // HashFlags the same and not individuals      // (3)
               if q(a(*px), a(*py))
               then { px.a := py.a := oldest(*px, *py).a;
                      true; }
               else false;

def qb(px, py) = if q(b(*x), b(*y)) // HashFlags same for the pairs
               then { px.b := py.b := oldest(*px, *py).b;
                      true; }
               else false;
```

Reference count adjustments are not reflected. On exit, one
goes up, one goes down.  That can be handled in oldest(*px*, *py*).

Note that q(*x, *y) is used in these procedures so there is no
benefit at deeper levels. We can address that next.

There are three pseudo-leaps here:

* Assignment (:=) is not good Frugalese but it is needed in
  describing such low-level stateful operations.

* Because we are recursing through q(*x*, *y*), coalescing could happen on any
  matches down in the recursive descent even though, overall, the compared
  full ob structures are not identical. It takes some experimentation to see
  what's worthwhile here.  A fall-back would be to coalesce only on the top
  level of the collision.

* There is a presumed method of determining which of two equal obs should
  be substituted for the other.  The heuristic idea of using "oldest"
  is to employ the one appearing to hang around the longest (based, say, on
  reference-count comparisons).

Finally, at an initial entry to q(*x*, *y*), we have nothing helpful at that
presumably top-level case.  That's not so easy to remedy.  We can handle
that similarly to introduction of qa and qb though.

```text
def qp(px, py) = ( if *px = *py // references to same ob-cells // (4)
                   then true  // the pointers are to the same ob
                   else if hashflag(*px) ≠ hashflag(*py)
                        then false
                        else // they have identical Flags as well as Hashes
                             if is-individual(*px)
                             then false // same individual only if same loc
                             else if is-enclosure(*px)
                                  then qa(px, py)
                                  else qa(px, py) and qb(px, py)
                   )
                 where qa(px, py)
                         = if qp(&a(*px), &a(*py))
                           then { px.a := py.a := oldest(px, py).a;
                                  true; }
                           else false,
                       qb(px, py)
                         = if qp(&b(*px), &b(*py))
                           then { px.b := px.b := oldest(px, py).b;
                                  true; }
                           else false;

```

and it is the idea that matters, not the purity of this pseudo-code.


## 6. Experimentation and Instrumentation

There is going to have to be much instrumentation and trials to determine
if coalescing of matching but different ob-cells matches is worthwhile, and
at what level.

There also needs to be a better way of descrion of the q-related functions
concerning parameter passing.  Frugalese is too pure for this kind of
manipulation.  That may leave it up to the C/C++ code.

## 7. Resources

\[[Knuth1993b](../../../../../bib/authors.htm#Knuth1993b)\] Knuth, Donald E.
*The Stanford GraphBase: A Platform for Combinatorial Computing*.
Addison-Wesley (Boston: 1963).  ISBN 978-0-321-60632-7 pbk.

\[[Knuth1998](../../../../../bib/authors.htm#Knuth1998)\]
Knuth, Donald E. Chapter 3, Random Numbers, in  *The Art of Computer
Programming, vol.2: Seminumerical Algorithms*, ed.3.  Addison-Wesley (Reading,
MA: 1998).  ISBN 0-201-89684-2

\[[Knuth1998b](../../../../../bib/authors.htm#Knuth1998b)\]
Knuth, Donald E. Section 6.4, Hashing, in *The Art of Computer Programing,
vol. 3: Sorting and Searching*, ed.2. Addison-Wesley (Reading, MA), 1998.
ISBN 0-201-89685-0.

----

I invite discussion about Miser Project topics in the
[Discussion section](https://github.com/orcmid/miser/discussions).
Improvements and removal of defects in this particular documentation can be
reported and addressed in the
[Issues section](https://github.com/orcmid/miser/issues).  There are also
relevant [projects](https://github.com/orcmid/miser/projects?type=classic)
from time to time.

<table border="0" cellspacing="3" width="100%">
  <tr>
    <td width="14%">
	<a href="index.htm" target="_top">
       <img border="0" src="../../../images/hardhat-thumb.gif" alt="Hard Hat Area"
            align="left" width="80" height="57">
       </a>
    </td>
    <td width="54%" valign="middle" align="center">
      You are navigating the <a href="../../../">Miser Project on Github</a></td>
    <td width="30%">
      <p align="right"><font size="-2">created 2026-02-12 by
         <a target="_top" href="../../../../orcmid">orcmid</a> </font></p>
    </td>
  </tr>
</table>
<!--

  0.0.7  2026-02-16T23:39Z Reflect the breaking change from .D to .Q here
  0.0.6  2026-02-16T18:05Z Touch-ups, handwringing on "distinction"
  0.0.5  2026-02-16T08:03Z Work out coalescing different matching ops
  0.0.4  2026-02-14T20:10Z Correct the second case on hashtags
  0.0.3  2026-02-14T02:40Z Improve title block, annotate the second case
  0.0.2  2026-02-13T04:52Z Improve an is-enclosure with is-singleton
  0.0.1  2026-02-13T02:11Z Initial distinction comparisons
  0.0.0  2026-02-12T21:49Z Initial placeholder draft.

               *** end of oMiser/2023/09/m230900c.md ***                  -->

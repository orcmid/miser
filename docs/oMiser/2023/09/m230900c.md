<!-- m230900c.md 0.0.5              UTF-8                         2026-02-16
     ----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*
     source <https://github.com/orcmid/miser/blob/master/docs/omiser/2023/09/m230900c.md>
     publication <https://orcmid.github.io/miser/omiser/2023/09/m230900c.html>
     -->
<table border="0" width="100%">
  <tr>
    <td width="25%" align="left" height="6">
       <a href="../../" title="The Miser Project on GitHub">
       <img src="../../../images/misertheory-logo.png" /></a>
    </td>
       <td width="48%" height="6"><p align="center"><font color="#990033"><strong>
	<i><a href="../../m000001.htm"><font color="#990033">oMiser Technical Note
    </font></a></i><br />
    <i><big><a href="m230900.htm"><font color="#990033">Hash Flag Technique
    </font></a></big></i><br />
    <i><big><big>Ob Comparison</big></big></i></strong></font></p>
    </td>
    <td width="27%" height="6" valign="middle" align="right">
      <b><tt>
      <a href="../../../../" target="_top">orcmid.github.io</a>&gt;
      </tt></b>
      <br />
      <a href="https://clustrmaps.com/site/1bw9w" title="Visit tracker">
            <img src="//www.clustrmaps.com/map_v2.png?d=3-2eQV4fOuelVHp_YtztZ0hl9Uj4ei9zLKw_nRgCgyM&cl=ffffff" />
      </a><br />
      <b>
      <a href="../../../" target="_top">miser</a>&gt;
      <a href="../../" target="_top">oMiser</a>&gt;
      <br />
      <a href="../" target="_top">2023</a>&gt;
      <a href="./" target="_top">09</a>&gt;
      <br /><br />
         <a href="m230900c.html" target="_top">m230900c</a>&gt;</b>
      <br />
      <small><small>
        0.0.5 2026-02-16T04:02Z<!-- MAINTAIN THIS MANUALLY -->
      </small></small>
      </td>
  </tr>
</table>

## 1. What Do HashTags Have to Do With Comparison

All ob-cells have a 32-bit HashTag.  If the ob-cell is also for an entitiy
that is anchored in the MOb manifestation directory, that HashTag can be
used to search for associated information about it, such as any symbolic name
in the case of a literal individual (lindy).

The reason that **all** ob-cells have a HashTag is so that it is easier to
determine whether two different ob-cells are for identical obs or not.  This
serves two purposes:

* First, if the different ob-cells have different HashTags, they are for
  different obs.

* Secondly, if the HashTags are the same, then they *might* be for identical
  obs.  If that identity is confirmed, there is potential for removing a
  duplicate and saving some storage along with avoiding a (prospective)
  subsequent HashTag collision.

The conjecture is that HashTags will expedite comparisons between obs
and the improvement is worthwhile.

The prospect of duplicate removal is not so clear and experiments along with instrumentation will determine whether that's a wild-goose chase or not.


## 2. The Abstract Comparison of Obs

In \[[obtheory](https://orcmid.github.io/miser/ob/obtheory.txt): Ob6.
Structural Identity\], the distinction/identity of two obs are in accordance
with 4 conditions.

```sml
        u = ob.c(v,w) ∧ z = ob.c(x,y)
                   ⇒ (u = z ⇔ v = x ∧ w = y)                  (a)

        u = ob.e(v) ∧ z = ob.e(x)
                   ⇒ (u = z ⇔ v = x)                          (b)

        ob.is-pair(u) ∧ ob.is-singleton(z)
                   ⇒ u ≠ z                                     (c)

        ob.is-individual(u) ∧ ob.a(z) ≠ z
                   ⇒ u ≠ z                                     (d)
```

This is sufficient to establish all of the cases, where individuals are never
duplicated and are distinguished by their names (and sometimes by their
construction in the case of synthetics introduced as oMiser extensions).


## 3. The Algorithmic Comparison of Obs

The following Frugalese pseudocode constitutes a comparision algorithm for two
ob-cells supplied as operands.

```sml
def d(x, y) = if &x = &y                                      // (3)
              then true
              else if is-individual(x) or is-individual(y)
                   then false
                   else if is-enclosure(x) and is-enclosure(y)
                        then d(a(x), a(y))
                        else if is-pair(x) and is-pair(y)
                             then d(a(x), a(y)) and d(b(x), b(y))
                             else false;
```

with the presumption that all ob parameters are passed by reference
and not by value.  Here &*x* is the reference to the ob-cell that was
supplied for parameter *x*.  In practice, pointers are handed around all of
the time and dereferencing them is implicit, as in something like a(*x*),
which yields a new reference.

Procedure d(*x, *y) relies on the fact that ob-cells for specific individuals
are never duplicated.  Each distinct individual is manifest with a single,
also-unique ob-cell.


## 4. The Benefit of HashFlags for Expedited Comparison

A valuable feature of HashFlags is that the Flag distinguishes the flavor
of the ob represented by the ob-cell. If the HashFlags are different,
the represented obs must be different.  If the HashFlags agree, the
represented obs are of the same structure.

This leads to useful streamlining:

```sml
def d(x, y) = if &x = &y                                      // (4)
              then true
              else if hashflag(x) ≠ hashflag(y)
                   then false
                   else // they have identical Flags as well as Hashes
                        if is-individual(x)
                        then false // same individual only if same loc
                        else if is-enclosure(x)
                             then d(a(x), a(y))
                             else d(a(x), a(y)) and d(b(x), b(y));
```

The usage of hash codes to quickly distinguish list structures in LISP was
pointed out by Paul McJones.


## 5. The Quest for Eliminating Duplications

When d(*x*, *y*) determines that two distinct ob-cells manifest the
same obs, it might be valuable to coalesce into one ob-cell in some manner.
That would have a recurrence of the comparison find that *x* and *y* have the
same location and provide a direct result.

It is speculative whether recurrence of a specific comparison is likely. What
follows applies when there is some indication that the additional effort
involved is worthwhile.

To accomplish this, we need to know where the references for *x* and *y* were
obtained.  That is, what were they found in that they could be altered in
order to reduce a duplication?

First, there are ones where we do know where we're coming from: going into
recursive steps d(a(*x*), a(*y*)) and d(b(*x*), b(*y*)) in (4, above).

So let's replace those with da(*x*, *y*) and db(*x*, *y*) so we pass in
references to the ob-cells that we're going to check parts of.  We now can
determine which cells the compared a-parts and b-parts are found in.  That is
enough to determine how to coalesce matches of obs in different locations.

In very-pseudo-Frugalese,

```sml
def da(x, y) = // HashFlags the same and not individuals      // (5)
               if d(a(x), a(y))
               then { x.a := y.a := oldest(x, y).a;
                      true; }
               else false;

def db(x, y) = if d(b(x), b(y)) // HashFlags same for the pairs
               then { x.b := y.b := oldest(x, y).b;
                      true; }
               else false;

    // Adjustment of reference counts str not reflected. On exit true, one
    // goes one goes down.  That can be handled in oldest.

    // Note that d(*x, *y) is used in these procedures so there is no
    // benefit at deeper levels. We can address that next.
```

There are three pseudo-leaps here:

* Assignment (:=) is not good Frugalese but it is needed in
  describing such low-level stateful operations.

* Because we are recursing through d(*x*, *y*), coalescing could happen on any
  matches down in the recursive descent even though, overall, the compared
  ob structures are not identical. It takes some experimentation to see what's worthwhile here.  A fall-back would be to coalesce only on successful match
  result at the top level.

* There is a presumed method of determining which of two equal obs should
  be substituted for the other.  The heuristic idea of using "oldest"
  is to employ the one appearing to hang around the longest (based, say, on
  reference-count comparisons).

Finally, at an initial entry to d(*x*, *y*), we have nothing helpful at that
presumably top-level case.  That's not so easy to remedy.  We can handle
that similarly with the introduction of da and db though.

```sml
def dp(px, py) = ( if *px = *py // references to same ob-cells // (6)
                   then true  // the pointers are to the same ob
                   else if hashflag(*px) ≠ hashflag(*py)
                        then false
                        else // they have identical Flags as well as Hashes
                             if is-individual(*px)
                             then false // same individual only if same loc
                             else if is-enclosure(*px)
                                  then da(px, py)
                                  else da(px, py) and db(px, py)
                   )
                 where da(px, py)
                         = if dp(&a(*px), &a(*py))
                           then { px.a := py.a := oldest(px, py).a;
                                  true; }
                           else false,
                       db(px, py)
                         = if dp(&b(*px), &b(*py))
                           then { px.b := px.b := oldest(px, py).b;
                                  true; }
                           else false;

```

## 6. Experimentation and Instrumentation Required

There is going to have to be much instrumentation and trials to determine
if coalescing matches is worthwhile, and at what level.



## 7. Resources ?

\[[Knuth1993b](../../../../../bib/authors.htm#Knuth1993b)\] Knuth, Donald E.
*The Stanford GraphBase: A Platform for Combinatorial Computing*.
Addison-Wesley (Boston: 1963).  ISBN 978-0-321-60632-7 pbk.

\[[Knuth1998](../../../../../bib/authors.htm#Knuth1998)\]
Knuth, Donald E. Chapter 3, Random Numbers, in  *The Art of Computer
Programming, vol.2: Seminumerical Algorithms*, ed.3.  Addison-Wesley (Reading,
MA: 1998).  ISBN 0-201-89684-2

\[[Knuth1998b](../../../../../bib/authors.htm#Knuth1998b)\]
Knuth, Donald E. Section 6.4, Hashing, in *The Art of Computer Programing,
vol. 3: Sorting and Searching*, ed.2. Addison-Wesley (Reading, MA), 1998.
ISBN 0-201-89685-0.

----

I invite discussion about Miser Project topics in the
[Discussion section](https://github.com/orcmid/miser/discussions).
Improvements and removal of defects in this particular documentation can be
reported and addressed in the
[Issues section](https://github.com/orcmid/miser/issues).  There are also
relevant [projects](https://github.com/orcmid/miser/projects?type=classic)
from time to time.

<table border="0" cellspacing="3" width="100%">
  <tr>
    <td width="14%">
	<a href="index.htm" target="_top">
       <img border="0" src="../../../images/hardhat-thumb.gif" alt="Hard Hat Area"
            align="left" width="80" height="57">
       </a>
    </td>
    <td width="54%" valign="middle" align="center">
      You are navigating the <a href="../../../">Miser Project on Github</a></td>
    <td width="30%">
      <p align="right"><font size="-2">created 2026-02-12 by
         <a target="_top" href="../../../../orcmid">orcmid</a> </font></p>
    </td>
  </tr>
</table>
<!--

  0.0.5  2026-02-16T08:03Z Work out coalescing different matching ops
  0.0.4  2026-02-14T20:10Z Correct the second case on hashtags
  0.0.3  2026-02-14T02:40Z Improve title block, annotate the second case
  0.0.2  2026-02-13T04:52Z Improve an is-enclosure with is-singleton
  0.0.1  2026-02-13T02:11Z Initial distinction comparisons
  0.0.0  2026-02-12T21:49Z Initial placeholder draft.

               *** end of oMiser/2023/09/m230900c.md ***                  -->

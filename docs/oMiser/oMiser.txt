oMiser.txt 0.1.11                   UTF-8                         2026-01-25
*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                           The Miser Project Code
                           ======================

             <https://orcmid.github.io/Miser/oMiser/oMiser.txt>

         OMISER CONCEPTION, DEFINITION, AND IMPLEMENTATION NOTES
         -------------------------------------------------------

    IMPORTANT NOTICE: The oMiser and oFrugal text-file materials are
        being refactored under docs/ where they are organized in
        conjunction with web materials.  This version is a place-holder
        and job jar on the docs/ side of this effort.  Construction
        Structure under docs/ provides the necessary manifest.  There
        will also be web-based Job Jars and Diaries. This page will be
        whittled down as the refactoring progresses.

        The original version of this file is tombstoned at
        <https://github.com/orcmid/miser/blob/master/oMiser/oMiser.txt>.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                    Copyright 2018-2026 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 ATTRIBUTION

   Hamilton, Dennis E. oMiser Conception, Definition, and Implementation
   Notes.  Miser Project text file oMiser.txt version 0.1.11 dated 2026-01-25,
   available on the Internet as a version of
   <https://oMiser.github.io/Miser/oMiser/oMiser.txt>.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

NOTES AND TODOS

  * [2026-01-25] These historical notes will disappear if/when acted upon.
    A better scheme might be sweeping these onto m000000.htm where they
    can be resolve or not, but always preserved.  This will only work as
    long as I can continue to use FrontPage though.

  * [2026-01-07] The spiraling needs to be in step with oFrugal development.
    So there needs to be an initial command-line operations that works in
    sync with addition of features in an instrumented spiral.  There may need
    to be an oFrugal feature with regard to instrumentation.

  * [2026-01-07] I have been obsessing about memory management, hashing
    tables and performance of RNGs and garbage collection.  Instead of making
    myself crazy digging into research publications I don't understand at the
    detail level, I am going into a test-first approach where I build things
    that work a little, instrument the heck out of it, and keep expanding
    as I get a grip on it bit-by-bit.  There may need to be occasional
    refactorings, but that has to be superior than being paralyzed.

  * 2023-11-06 Use "NBG" for von Neumann, Bernays, Goedel set theory and how
    it is used in model theory, although we will stay in the finitism realm
    for the domains of structures.

  * There is a note on Goedel vol.1 that points to Goedel accepting Turing
    Completeness (in a remark by Kleene) with respect to Church's Thesis. I
    should mention that to Edward.

  * 2023-11-05 There needs to be a way to save the complete state of oFrugal.
    That means the symbol table, not just a single entity.  It basically saves
    every ob that is reachable in oFrugal at the point of save/suspension.
    This might not be a 1.0 or 1.1 thingy.  Another way would be to export the
    def obs in some manner and also economize on shared obs in the reload.

  * 2024-01-27 Many of the TODOs here are about implementation of the oMiser
    run-time and its integration.  Development of the algorithms and their
    profiling is here, with releases and various code provided under the
    GitHub Miser dev/ and the docs/dev/ locations.  Reflect on index.htm.

  * Connect to internet-accessible resources and availability of stable
    materials when available.  TODOs and related work can be separated then.

  * Work up a COM-based interface protected implementation and see whether
    reference-counting is a workable avoidance of garbage collection by
    other means.

  * Check out Henry Baker's approach to using stack drag as a way to have
    rapid pair construction with only longer-lived material swept to the
    heap.  This is something he and I talked about at the first AAAI meeting
    at Stanford.  I had a skeletal Z80 implementation.  I think the Chicken
    Scheme one may be very desirable for x64 implementations.

  * Deal with experimental speed-up devices, including tail recursion,
    to determine whether they are effective storage-reduction measures.  There
    are other accelerator techniques that may cooperate with this.  It remains
    open to me whether tail recursion is detectable in obap.ap.

  * Consider a lab structure alongside the main dev and source-code
    structures.

  * Address platform variety (e.g., C/C++ versus .NET, Java, etc.) and
    also using oMiser at a binary level beneath systems such as Python.

  * Emphasize that this is a machine, machine data structure, and machine-
    language in the conventional sense.  And, at the oMiser/oFrugal level,
    we are basically seeing an assembler (reader) and a disassembler (printer)
    of the oMiser machine code.  Where oFrugal becomes more interesting may
    be with Proc and maybe something about data structures. [2025-11-10: I am
    calling these synthetics now.]

  * The Golden Geek treatment of the connection between these could perhaps
    be handled with an oMiser.md page here.  That could also address the
    programming notions.  It ties in the development of the "reference
    notation" for obs and the two sugared forms: lists, and expressions.
    See <https://www.facebook.com/MiserProject/> for now.

  * The grammar for reference notation is also needed, along with the
    oFrugal REPL additions (saving and substitution, etc.).

  * When representation, interpretation, manifestation, implementation,
    and simulation are worked out more clearly, review these materials
    for consistent usage and links to related resources of the project and
    and elsewhere, especially ones of reference/historical value.

  * There are a number of engineering and programming matters in these TODOs
    that are best moved to an alternative place, such as engineering.txt
    for the overall project.

  * The fundamental reference that is a historical inspiration for obs and
    oMiser is [McCarthy1960] McCarthy, John.  Recursive functions of symbolic
    expressions and their computation by machine, Part 1.  Comm. ACM 3, 4
    (April 1960), 184-195, https://doi.org/10.1145/367177.367199

  * I should also point out that the James Allen book, "Anatomy of LISP"
    was inspirational in how it continued the sort-of-meta level that McCarthy
    used in the original paper, but did not carry very far.  My efforts with
    ‹ob› structure and then the universal computational function (obap) are
    firmly in what I take to be in the James Allen spirit, but with more
    mathematical logic.

  * A related article of possible interest in accelerators or possibly other
    situations is [Perlis1960] Perlis, A.J., Thornton, Charles.  Symbol
    manipulation by threaded lists.  Comm. ACM 3, 4 (April 1960), 195-204,
    https://doi.org/10.1145/367177.367202

  * The Strachey General-Purpose Macro Processor (McG) is also inspirational,
    as is the Burge and Landin work on applicative systems and ISWIM.

  * How did the Mapping of ALGOL 60 to the lambda calculus deal with
    assignment operations and storage state?  It looks like continuations
    are fruitful, if the compute expression of F# is informative.  I still
    haven't got my head around it (2023-01-11).  [2025-11-10 I don't think
    continuation is the correct term - it is more about passing and returning
    stateful objects, but it is more about transformation, not continuation.]

  * EMERGENCE OF TYPES AND "OBJECTS" is a key matter. It is at the heart of
    the stored-program model and it serves to illustrate the limits of
    computable functions to within denumerability. In some sense, the larger
    the domains of discourse (in cardinality terms), the computable functions
    are a tinier and tinier subset.

  * INTERPRETATION MATTERS and some constructions are strictly mystery meat
    in the absence of any expression of intended interpretation.  I suppose
    at some point one arrives at a perspective on category theory, although I
    will need to understand Eugenia Chang's portrayal better.

  * Use the ability to create interpretations over a sufficient model of
    computation to motivate the narrative about oMiser and what works for it.
    The lindy trace hack and an extended syntax for it get around the need
    for other data types, since lyndies give us sufficient literals for
    atoms in strings (list structures).

  * On 2000-05-12 (#20.65) I start thinking about Miser objects and operating
    on a local system with flat namespace.  I am contemplating something like
    COM for attaching implementations to ob-cells, as it were.  I'm not there
    yet though.

 * On 2000-06-09 (#21.15) I muse about using Scheme after seeing "The Little
   Schemer" in Borders.  But I learned Scheme does not have immutable obs,
   so I could simulate obs there but it didn't feel great.  Later I found SML
   more appealing and I started there.

 * On 2000-06-10 (#21.19-20) I am thinking about Python obs or using the
   C code to introduce Miser obs into Python.  I also start to ponder
   distributed operations and get wary about individuals having state being
   a problem for that.

 * On 2001-01-23 (#27.51-52) I worry myself about features but more famously
   that every individual of a class be typical of the class.  I will sort
   this out in the computational model.  I had imagined that COM interfaces
   help with demonstration of that. To make this more specific look at it
   this way. Numbers as we think of them do not have independent identity from
   number theory.  That is, a feature of the numerical interpretation of
   something like 3.14159 is more than just a sequence of seven glyphs.
   There's a context in which that is distinguished as signifying a member of
   some mathematical class and it is the whole of that (conceptually) that the
   individual connects into.  In some sense, each individual evokes the whole
   and in a computer representation I fancy that individuals should provide
   access to manifestation of any (though not literally the whole of course).

 * On 2001-05-24 (#30.9-10) I go off on VTables, the idea that ob-cells (not
   called that yet) have a VTable pointer at the top, just like binary COM
   objects.  I am working on the problem of a functions reached by VTable
   working best if it knows the implementation behind a ppv provided as a
   parameter of a VTabled function (e.g., for apply).  I observed that I can't
   use QueryInterface to deliver the implementation, because it violates
   remoting (even though I expect to only be doing in-process COM).  My
   solution is to have an IID that on QueryInterface returns access to the
   implementation.  In this case, the only question is about the requesting
   application.  So that IID should be obtained as part of the generation
   (in the COM sense) of an oMiser instance.  It should be generated randomly
   and be very unlikely to be recognized by a stub of a remote or even a
   co-resident instance of oMiser. [2025-11-10 And while I rhapsodying on
   this, I should point out that having two running instances in the same
   process is rather unlikely because of the way memory-management is
   intended to work.]  The key thing is that if the QueryInterface with that
   IID fails, we know we're not dealing with an object of the oMiser instance
   that is asking and so no assumptions about its run-time can be assumed.

 * On 2001-05-25 (#30.15) I get into the problem on releasing individuals
   because there may be much more than just the ob-cell involved. My fear was
   that I would need to know when the Garbage Collector is releasing an
   individual, if allowed at all, and that doesn't let me do the Henry Baker
   scrap-it-all stack retreat after moving only ob-cells that there are
   references to from outside heap-0, as it were.  I am thinking at this
   (2025-11-10) moment that individuals never go onto heap-0 and they will
   always be reference-counted.  There is then some serious difficulty with
   synthetics -- individuals that hold obs in their definitions and must not
   appear to be younger than the ob they are holding onto.
      IT SEEMS, AT THIS MOMENT, THAT CREATION OF A SYNTHETIC REQUIRES INSTANT
   GENERATION-MOVEMENT OF THE OB THAT THE SYNTHETIC MUST HOLD AND BE ABLE TO
   DELIVER.  Now that I think about it, the precedence rule requires this. If
   I play my cards right, the Cheney copy rule should just work. I just hope
   there's no joker in the deck.  The trick might be knowing what individuals
   were established during the creating of a heap-0 and so we know who to
   preserve before retreating heap-0.  This might have to work through all
   of the generations.

 * On 2001-05-26/27 (#30.33) I ponder a progression involving completion of
   an ob theory, something about manifestation and also how individuals work
   and are distinguishable.  I haven't come up with lindies yet.

 * On 2001-05-27 (#30.34-35) I am still lost on indentity between individuals.
   I come up with "in computing and especially the implementation of
   programming languages, we appeal to mathematical concepts for explanation
   and identification of concepts for the function of the language.  Then, we
   introduce pragmatic considerations in a way that undermines the
   mathematical function."

 * On 2001-05-27 (#30.35) I have some terrible ideas for Iob interfaces
   (maybe) and I'm too much in love with C++ notions.

 * On 2001-05-29 (#30.38-40) I am getting lost in Ob [COM] Interface
   principles.  I am thinking of some sort of hybrid sort-of-COM operation,
   but not thinking clearly about tagging of Ob form (individual, enclosure,
   pair) and so on.

 * On 2001-06-01 (#30.44) I start rambling about Ob brokers determined Obs.
   My conclusion is that communication of canonical forms is all it takes.

 * On 2001-06-15 (#30.51) I am pondering what I now term "~~real~~idealism."
   "The idea is that we always see things in a process space as if there is
   this persistent, consistent world.  Whenever process spaces are connected,
   the behavior is as if there is only one world visible to all of them.
   This is an illusion and we have to be careful."
   I was definitely over-thinking this, because it does not concern me today
   (2025-11-10).[2025-11-17 The term is "idealism", not "realism."]

 * On 2001-07-26 (#30.76) I am musing about Obs that carry values (ie., now
   called synthetic individuals) and get that difference of the synthetics
   does not imply difference in their values (although I now intend to make
   that the case), and that if the the obs are identical, they necessarily
   carry the same values.

 * On 2001-09-08 (#31.11) I start wondering about the cost of creation/
   deletion/use of ob-cells.  The cost of creation happens exactly once and
   the cost of deletion happens exactly once for an occurrence.  So we can
   treat it all as the cost of creation.  I do wonder about when I can avoid
   an addref (if reference counting).  I do suggest that a special case in
   comparison does not alter any references someone is already holding. I
   think this is about the prospect of consolidating references when two obs
   in different ob-cells are found to be identical.  That definitely has
   reference-counting impacts. [2025-11-17 not particularly, it decrements
   one and increases another, that's all. We might have some performance
   issues on what happens when a count gets to 0, and more about threading
   things together in generations.  Using symmetric lists is the best trick.
   But we're now talking about holding more pointers, somewhere.  Because it
   is intended to have HashFlags indicate when a(x) and b(x) self-referencing
   we could use those link slots for other things. That could be messy but
   checking the flags should be more efficient than traversing a pointer,
   shouldn't it?]

 * On 2002-01-24 (#32.16-17) I am still pondering basic operations on a COM-
   like interface structure.  So there is a class factory call and we get
   an interface (essentially the IUnknown) back but also a "key" that is used
   to ask for access to the run-time instance storage as if via an interface.
   When successful, it allows the interpreter to go beneath the covers and
   operate much more efficiently. It might be the case that this always works,
   but this allows for the possibility of remoting across multiple Miser
   instances.

 * On 2002-02-24 (#32.61-64) I'm setting up <https://miser-theory.info>. That
   is defunct and what matters is being moved to orcmid.github.io/miser.  I do
   note that there is a call for a binding check.  That's more about providing
   the class factory with a parameter struct that reveals the caller has run-
   time assumptions that applies to the library that is bound/linked with
   the app that uses the Miser run-time.  This might not be necessary. I am
   still fiddling with COM-style API.

 * One thing I notice on the #32.63 is that I have two version of ob.c, one to
   put the other as an a-part with self, one to put the other as a b-part with
   self.  The same could go with apply then.  Checking for equality doesn't,
   though it might matter under the covers with regard to remoteness.  If all
   local, comparison just runs rampant directly in the storage without having
   to use the COM API.

 * On 2002-06-04 (#34.18) I raise the issue of Miser Trust Points.  This has
   to do with determining that an implementation has been compromised or that
   an user of the API appears to be compromised.  I have no recollection now
   and think the question might be at the wrong level.  I need to go back into
   the cybersecurity materials where Trust Points come up, and recalibrate.

 * On 2002-08-04/05 (#34.86) I bothered myself about transfinite as
   unreachable and I have no idea why that matters for what I now officially
   call oMiser.

 * On 2002-08-10 (#34.93) I'm back wondering about failure modes, the identity
   and distinctness matters, and some examples of symbols that are needed.

 * On 2002-08-13 (#34.99) I am now pondering self-reference, but it is not
   an issue and cycles are simply not allowed in Obs. I do identify some
   problems over mutual recursion though, and have a case in obap itself.

 * On 2002-08-28 (#35.33) I mention Computational Logic but don't explain
   what matters or what I am expecting in that respect.  I do mumble about
   hidden side-effects in oMiser being OK though.  That is, things that
   happen under the covers that in no manner interfere with the appearance
   of immutability.

 * On 2003-07-01 (#40.41) I mention alternative ways of doing combinator S.
   I think this has to do with simplifying when some of the operands are
   non-recursive and can sort of be spliced in-line.  There is obap.f now,
   but I think this is taking even more advantage of the structure of the
   first two operands.

 * On 2004-10-18 (#44.41) I am musing about individuals, procs, and
   reflection.  It will be the case that if x = y, proc x = proc y. And vice
   versa. I thought there was an extensionality question, but I don't think
   so.  It is all still about obs and obap.

 * On 2006-06-18 (#52.25) I observe that the way to handle (a ∨ b) is with
   ¬(¬a ∧ ¬b) in Wang's algorithm.  I have another wrinkle that has with two
   stacks of hypotheses, affirmed ones and denied ones.  The bigger thing
   about this is that I have gone 2 years without working on the Miser Project
   and now about to resume.

 * On 2006-06-25 (#52.52) I muse about caching individuals (namely synthetics)
   but I don't think it matters so much as simply keeping individual ob-cells
   unique.  Their locations might be reference-counted. I made an observation
   that individuals should always be moveable, but I don't think that works.

 * On 2006-09-17 (#54.103) I'm at ICFP in Portland, Oregon.  It is somehow
   inspiring.  But here I fuss about oMiser Identity and needing an identity
   "oracle."  I was thinking that proc (now a case of synthetic) somehow
   needed such a thing, when the solution is simply not to ever make duplicate
   procs (in an instance).  Now (2025-11-11) I wonder how remoting preserves
   that.

 * On 2006-09-17 (#54.103) And I also get confused about extensibility, I
   think.  I see that I am using "oracles" with respect to discriminators,
   being able to determine that an individual is a proc, for example.  I have
   a solution that's quite different.  I also had a foolish idea that
   ap(ob.ARG, x) is x, and ap(ob.SELF, x) is ob.SELF.  That's not how these
   will end up.

 * On 2006-09-17 (#54.104) I talked with Carl Hauser (known previously at
   PARC) at ICFP and came up with the idea that oMiser shows something about
   proofs by symbolic extension.  I have no idea what I meant by that note.
   I did get that λ is programmable, and I thought it got into handling traces
   (now called symbolic forms) and it does.

 * On 2007-11-05 (#59.84) I consider "code formats" with XML streams that are
   slow to write but fast to read, and also enclosing in an OPC container
   (or the ODF equivalent), and also self-contained/-extracting executables.
   Just musings at that point.  [2025-11-07 for Fast reading, the XML must
   provide a kind of reverse Polish and in that case, producing the XML
   requires topological sorting and a kind of labelling and back pointing to
   shared ob-cells.  But that says more, now, about needing a symbol table
   for those at least while loading.  This has me thinking about Knuth's
   assembly-language "program points" though that's not really it.  It does
   mean that the HashFlag is not enough in this case. There needs to be a
   generated label, and whether those can be reused in the stream is up for
   grabs.]

 * On 2010-10-07 (#65.119) I turn my attention to Miser Accelerators.  In
   this case it is about having some sort of block of extended data and an
   ob-cell that refers to it and is reference by it.  The idea is to treat
   the extended-data block holding more than the ob-cell.  The ob-cell is
   taken to be the holder, but it is holding something that is also memory-
   managed and they need to be preserved/released together.  I am thinking
   of *proc* obs in this case.
    - I say I need a way to mege holders when two are found to be the same.
      This becomes unnecessary (2025-11-15) because these are tied to
      individuals. Ideally, there's only one block of storage with common
      ob-cell on top and the memory-manager knows what to do.  That needs to
      deal with accelerators happening later than creation of an ob-cell, so
      I must ponder that.
    - If cross-referencing happens, and the thing or its parts are moved,
      I do have to work out reference counting and other release mechanisms.
      I will need some compare-and-swap or other mechanism to avoid race
      conditions.
    - 2025-11-15: I do need to look at the AED Free-store system and also
      how this can fit with Henry Baker's generational scheme.  The longer-
      lived heaps may just be managed differently. Murky topic to be
      handled by new folio needed now.

 * On 2011-04-22 (#66.98) I Make notes on Hash Tables and gather some useful
   references.
    - [Litw80] Litwin, Witold.  Linear Hashing: A New Tool for File and Table
      Addressing. pp.212-223 in Proceedings of the 6th International
      Conference on Very Large Databases (VLDB), Montreal Quebec, Canada,
      October 1980.
    - My foray into the Nemes patent stuff,
      <http://lwn.net/Articles/439720/>.  My commentary begins at
      <https://lwn.net/Articles/439733?>.  This is about infringement of a
      patent involving incremental garbage collection in a "linear" hashing
      system.  The patent is about opportunistic deletion of unused entries
      and a possible shrinkage of the number of buckets containing all of
      the items (or at least a portion of the items that is needed to search
      with).  In the scheme, the number of buckets (each having groups of
      keys) is increased as the database increases.  There's nothing about
      key distributions and key popularity.  That's outside the perview.
      The patent seems to be aboupt opportunistic removal of dead items
      while searching through the items in a bucket.  There also needs to
      be some consideration of shrinking the number of buckets as things
      become sparse, but that might not be relevant, depending on the
      application. On 2025-11-15 I captured the LNW.net discussion of this,
      starting with my first comment, in
      LwNet-2011-04-21-2131-ThreadOnNemesPatentForLinearHashingDeletions.pdf
      I am interested in this as part of the hash-table lookup and this aspect
      of memory management can be considered to have been looked at starting
      in 2011.

 * ACTIONS ON HASHING. There needs to be an oMiser folio on Memory Management.
   There is a collateral matter for linear hashing that is collateral with
   memory management.  Mmm, maybe more than collateral since all individuals
   and many others may have accelerators or any kind of synthetic "behind"
   them.  And if other ob-cells can have accelerators, it gets sort of
   important to share those, if not the ob-cells themselve.  This can make
   the improvement of comparisons even more valuable at some point.  A ton of
   performance modeling is going to be needed though.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 0.1.11 2026-01-25T19:26Z Proposing to sweep all of these note onto m000000
        where they are preserved even after action is taken.
 0.1.10 2026-01-07T23:53Z Hand-wring about my going obsessive on perfection
        and needing to start small and iterate/spiral
 0.1.9  2025-11-17T20:42Z Correct "realism" to "idealism" and add some further
        musings
 0.1.8  2025-11-16T10:11Z Complete notes capture through #66
 0.1.7  2025-11-12T00:11Z More historical notes
 0.1.6  2025-11-11T19:27Z Backing up what I have so far
 0.1.5  2025-11-11T02:57Z Continue old-notebook clippings
 0.1.4  2025-11-10T04:47Z Start gathering material from old notebooks,
        cross-posting as seems necessary at the time
 0.1.3  2024-01-27T19:30Z Clean up TODOs and connection with tombstone.
 0.1.2  2023-11-06T18:59Z Note about NBG and how it might come up.
 0.1.1  2023-11-05T21:32Z Additional TODO about save/suspension in oFrugal.
 0.1.0  2023-11-01T18:55Z Transposition from oMiser/oMiser.txt to
        docs/oMiser.txt as part of refactoring Miser Project materials.

                         *** end of oMiser.txt ***

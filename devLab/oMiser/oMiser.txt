oMiser.txt 0.0.7                    UTF-8                       dh:2026-01-24
#---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                             The Miser Project Code
                             ======================

                        <https://github.com/orcmid/miser>

                 DEVELOPMENT OF MISER PROJECT SOFTWARE RELEASES

                    INCREMENTAL DEVELOPMENT OF MISER SOFTWARE
                    -----------------------------------------

   <https://github.com/orcmid/miser/blob/master/devLab/oMiser/oMiser.txt>

    oMiser is developed as a collection of header (*.h) and C Language
    (*.c) files.  Some of the files may be platform specific and their
    names (i.e., *-Win32.c) will reflect that.

    oMiser source code is meant to be taken as a library.  It is undecided
    whether a *.lib packaging of the compiled sources is to be provided.
    All early development of oFrugal will compile and use the oMiser source
    code directly.

    It is expected that oMiser will be created and usable via in-process
    COM interfaces, usable in C and C++ languages.  Whether or not that
    becomes the official API, techniques for encapsulation and hiding of
    implementation details will be featured in the chosen API.

    Because performance is crucial at the low level of operations with
    ob-cells, there are also means by which API operations, such as the
    apply and eval functions, can short-circuit the externally-offered API
    to maximize performance.

    Performance/stress testing will determine the degree to which COM
    interfaces are suitable.  Integrated testing with oFrugal will also
    determine whether or not the COM interfaces are an impediment to having
    the parser be input bound.


MANIFEST

    oMiser.txt  this manifest and job-jar file

       src/     all source code for oMiser

     tests/     all tests using only oMiser, separate from the combined
                testing of oFrugal builds

       COM.txt  Usage of COM for oMiser, featuring C/C++ interface usage

  HRESULTs.txt  Principles for choice of HRESULTs returned from oMiser API
                functions, including methods of COM interfaces.


*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                       Copyright 2026 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

ATTRIBUTION

   Hamilton, Dennis E. Incremental Development of oMiser Software.  Miser
   Project text file oMiser.txt version 0.0.7 dated 2026-01-24, available
   on the Internet as a version of
   <https://github.com/orcmid/miser/blob/master/devLab/oMiser/oMiser.txt>

NOTES AND TODO

  * I had this weird musing which would be a hallucination if copilot
    suggested it.  I have the idea that the creation of an oMiser structure
    should return a randomly-generated "key" by which an oMiser operation
    could determine whether a object (via COM-(like) interface) could be
    determined to be in the same oMiser instantiation as the one that will
    rely on it.  This is important with regard to applicative operation and
    other things.  It needs to be known that an operand is "local" before
    diving in and using direct access to the implementation of an instance.
       The musing is that an instance should return a PPV for itself.  That
    is, the instance is itself a gigantic COM-like object.  It doesn't have
    to have a giant block of contiguous storage, but it is the to foundation
    for whatever memory-management is hung off of it.

  * [2026-01-14] I am getting worked up about how complicated COM is versus
    how simple it is to provide in-process interfaces.  There need be no
    interaction with the COM SCM, and in any case, it should all be hidden.
    So the use of COM SCM functions should be completely hidden.  It is just
    the interface model I am interested in, without any difficult dressing.
    The trickiest business will be around using ppv pointers, using HRESULTs,
    and using GUIDs for things.  That has to be enough, but the machinery is
    hidden other than that.

  * [2026-01-14] The difficulty at a lower level has to do with what interface
    is delivered when ob-cells are navigated. This seems messy because we're
    delivering ppv (a pointer to the beginning of an ob-cell where there's
    a pointer to a function-entry vtable).  The ppv, the location of the
    ob-cell for example, is provided as the first so it is known which ob-cell
    (or other instance structure) having that interface is being pointed at.

  * [2026-01-14] I am uncertain how this handling of ob-cells works with
    regard to garbage collection.  Garbage collection depends on knowing
    what is referenced, and has to be moved.  But that means all ppvs that
    refer to the ob-cell have to be known in order to for it to be moved.  So
    it doesn't work if all we have is a reference count but no idea who is
    doing the referring.  One can't go fix ppvs wherever they might be held.

  * [2026-01-14] I think the oMiser interfaces need to be the least that are
    needed for an oFrugal to work.  I think the definition of semantics and
    the construction of the parser tells us what that is. I think we need
    a way to thread through ob-cells (or have them on a list) that lets us
    tell which ones are somewhere that they can be moved.  I need to be
    careful here.

  * [2026-01-14] This strikes me as weird.  It feels like there is something
    outside of ob-cells, but intimately connected, that determines what
    ob-cells are live in a way that they can be removed from that structure
    or generationally moved.  But that puts us back in the previously-
    unsolved problem.  In what way do they get "moved" if not removed.

  * I need to work on the header technique that was used for the JNI
    integration of ODMA.  It allows headers for objects to compile as C++
    virtual   interfaces or as C Language structures with the PV at the
    beginning.
      I think it must be in the definition of the JNI header used with
    <https://nfocentrale.com/nuovodoc/products/ODMJNI10.htm>.  It might be
    in the ODMpractical stuff.

  * Create a substructure for oMiser construction that initially
    has oMiser be a cached build for oFrugal and they spiral together.

  * Look into multi-platform support at the potential production library
    level for C/C++ constructed libraries for oMiser and using oMiser.
    Reconcile with the desire to minimize tooling and preservation of
    an on-ramp for enthusiasts, students, and novices.

  * I want to work through nicknames for oMiser builds - making a list that
    goes through the advent of flight until space and deeper things.
    For starters: oragami, balsa, wind tunnel, Kitty Hawk, Sputnik, (famous
    test pilots), (the dog), (the monkey), Gagarin, Glenn, ..., Tranquility Base, ...  There're also Hermes and Artemis and anything else in nifty
    science fiction.  So [Tau] Ceti then, also.


*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 0.0.7 2026-01-24T23:02Z More musing
 0.0.6 2026-01-24T20:32Z Musing about build nicknames
 0.0.5 2026-01-15T17:35Z Add COM.txt
 0.0.4 2026-01-15T17:15Z Add HRESULTs.txt, touch-ups
 0.0.3 2026-01-14T17:28Z Musing on a paradox around being garbage-collectable
 0.0.2 2026-01-12T17:31Z Synopsis and attribution
 0.0.1 2026-01-10T18:20Z Rhapsodize on one giant COM object
 0.0.0 2026-01-08T16:14Z Create placeholder and initial job jar for the
       oMiser library code.

                        ***** end of oMiser.txt *****

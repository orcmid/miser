oMiser.txt 0.0.2                    UTF-8                       dh:2026-01-12
#---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                             The Miser Project Code
                             ======================

                        <https://github.com/orcmid/miser>

                 DEVELOPMENT OF MISER PROJECT SOFTWARE RELEASES

                    INCREMENTAL DEVELOPMENT OF MISER SOFTWARE
                    -----------------------------------------

   <https://github.com/orcmid/miser/blob/master/devLab/oMiser/oMiser.txt>

    oMiser is developed as a collection of header (*.h) and C Language
    (*.c) files.  Some of the files may be platform specific and their
    names (i.e., *-Win32.c) will reflect that.

    oMiser source code is meant to be taken as a library.  It is undecided
    whether a *.lib packaging of the compiled sources is to be provided.
    All early development of oFrugal will compile and use the oMiser source
    code directly.

    It is expected that oMiser will be created and usable via in-process
    COM interfaces, usable in C and C++ languages.  Whether that becomes the
    official API, techniques for encapsulation and hiding of implementation
    details will be featured.

    Because performance is crucial at the low level of operations with
    ob-cells, there are also means by which API operations, such as the
    apply and eval functions, can short-circuit the externally-offered API
    to maximize performance.

    Performance/stress testing will determine the degree to which COM
    interfaces are suitable.  Integrated testing with oFrugal will also
    determine whether or not the COM interfaces are an impediment to having
    the parser be input bound.


MANIFEST

    oMiser.txt  this manifest and job-jar file

       src/     all source code for oMiser

     tests/     all tests using only oMiser, separate from the combined
                testing of oFrugal builds


*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                       Copyright 2026 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

ATTRIBUTION

   Hamilton, Dennis E. Incremental Development of oMiser Software.  Miser
   Project text file oMiser.txt version 0.0.2 dated 2026-01-12, available
   on the Internet as a version of
   <https://github.com/orcmid/miser/blob/master/devLab/oMiser/oMiser.txt>

NOTES AND TODO

  * I had this weird musing which would be a hallucination if copilot
    suggested it.  I have the idea that the creation of an oMiser structure
    should return a randomly-generated "key" by which an oMiser operation
    could determine whether a object (via COM-(like) interface) could be
    determined to be in the same oMiser instantiation as the one that will
    rely on it.  This is important with regard to applicative operation and
    other things.  It needs to be known that an operand is "local" before
    diving in and using direct access to the implementation of an instance.
       The musing is that an instance should return a PPV for itself.  That
    is, the instance is itself a gigantic COM-like object.  It doesn't have
    to have a giant block of contiguous storage, but it is the to foundation
    for whatever memory-management is hung off of it.

  * I need to work on the header technique that was used for the JNI
    integration of ODMA.  It allows headers for objects to compile as C++
    virtual   interfaces or as C Language structures with the PV at the
    beginning.
      I think it must be in the definition of the JNI header used with
    <https://nfocentrale.com/nuovodoc/products/ODMJNI10.htm>.  It might be
    in the ODMpractical stuff.

  * Create a substructure for oMiser construction that initially
    has oMiser be a cached build for oFrugal and they spiral together.

  * Look into multi-platform support at the potential production library
    level for C/C++ constructed libraries for oMiser and using oMiser.
    Reconcile with the desire to minimize tooling and preservation of
    an on-ramp for enthusiasts, students, and novices.


*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 0.0.2 2026-01-12T17:31Z Synopsis and attribution
 0.0.1 2026-01-10T18:20Z Rhapsodize on one giant COM object
 0.0.0 2026-01-08T16:14Z Create placeholder and initial job jar for the
       oMiser library code.

                        ***** end of oMiser.txt *****

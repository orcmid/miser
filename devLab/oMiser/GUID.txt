GUID.txt 0.0.2                      UTF-8                          2026-02-02
*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                                 OMISER CODE

                            OMISER USE OF GUIDS
                            ===================

    GUIDs are used to identify interfaces of COM object instances.  Some
    GUIDs are fixed as part of the COM specification.  Others are generated
    for oMiser-specific purposes.  The organization of interfaces satisfies
    the requirements of oFrugal having an abstracted interface to oMiser for
    oFrugal REPL operation.

    An important reliance of GUIDs is related to interface versioning.  When
    an interface contract changes, the evolved interface will have a new
    unique GUID.  In this manner, code designed to operate with a previous
    version of the interface can be preserved, and if not, the loss of
    support can be reported via a suitable HRESULT.

    The standard GUIDs that are claimed by Microsoft for COM/OLE
    consist of the following.  Note that we group them by the low-order 5
    bits because of how they must not conflict with oFrugal choices having
    the same lower bits in a situation in which the OLE IID might be
    supported.

    On Windows, it is typically defined in guiddef.h (included via objbase.h
    or windows.h) as a typedef for a struct:

    typedef struct _GUID {
        unsigned long  Data1;   // 32 bits
        unsigned short Data2;   // 16 bits
        unsigned short Data3;   // 16 bits
        unsigned char  Data4[8]; // 64 bits
        } GUID;

    Breakdown of Fields

        Data1: 4 bytes (DWORD)
        Data2: 2 bytes (WORD)
        Data3: 2 bytes (WORD)
        Data4: 8 bytes (BYTE array)

    This structure matches the standard UUID layout defined in RFC 4122.

    To have a fast-filtering set of GUIDs, the obvious choice is branching
    on the lowest 4 (16 choices) or 5 (32 choices) bits of Data1.  This
    allows for fast switching and checking by comparison with the oMiser-
    supported GUID having that pattern.

    What we don't want is a clash with defined OLE GUIDs that we might also
    want to provide interfaces for.  For example, we must not conflict with
    IID_IUnknown, and that has to be supported on every oMiser QueryInterface
    implementation.

    Here are known OLEGUID definitions from various sources, grouped by
    their matching the lowest 5 bits of Data1:

    DEFINE_OLEGUID(IID_IUnknown,        0x00000000L, 0, 0); Reserved
    DEFINE_OLEGUID(IID_IDispatch,       0x00020400L, 0, 0);
    DEFINE_OLEGUID(IID_IEnumUnknown,    0x00000100L, 0, 0);

    DEFINE_OLEGUID(IID_IClassFactory,   0x00000001L, 0, 0);
    DEFINE_OLEGUID(IID_IEnumString,     0x00000101L, 0, 0);

    DEFINE_OLEGUID(IID_IMalloc,         0x00000002L, 0, 0);
    DEFINE_OLEGUID(IID_IEnumMoniker,    0x00000102L, 0, 0);

    DEFINE_OLEGUID(IID_IMarshal,        0x00000003L, 0, 0);
    DEFINE_OLEGUID(IID_IEnumFORMATETC,  0x00000103L, 0, 0);
    DEFINE_OLEGUID(IID_IDebug,          0x00000123L, 0, 0);

    DEFINE_OLEGUID(IID_IEnumOLEVERB,    0x00000104L, 0, 0);
    DEFINE_OLEGUID(IID_IDebugStream,    0x00000124L, 0, 0);

    DEFINE_OLEGUID(IID_STATDATA,        0x00000105L, 0, 0);


Some others that might need to be minded,

    /* storage related interfaces */
    DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
    DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
    DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
    DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

    /* moniker related interfaces */
    DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
    DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
    DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
    DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

    /* storage related interfaces */
    DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
    DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
    DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
    DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

    DEFINE_OLEGUID(IID_IOleLink,            0x0000011dL, 0, 0);


    We could also over-use among the 16/32 cases when we're dealing with
    instances of different oMiser classes.


UTILITY FOR GENERATING GUIDS

    The utility is at BuildTools/Common7/tools/guidgen.exe for me.  It does
    not allow generation of blocks of GUIDs, unfortunately.  I might be able
    to do it by making variations.  I should check that.  Here are a few,

// {F47081DE-AB5B-4E9D-9C40-7601C24E7060}
   static const GUID <<name>> =
{ 0xf47081de, 0xab5b, 0x4e9d, { 0x9c, 0x40, 0x76, 0x1, 0xc2, 0x4e, 0x70, 0x60 } };

// {94CC012C-E179-4CCD-AF60-95B8F8952003}
static const GUID <<name>> =
{ 0x94cc012c, 0xe179, 0x4ccd, { 0xaf, 0x60, 0x95, 0xb8, 0xf8, 0x95, 0x20, 0x3 } };

// {C62F1021-E130-42BC-A26B-29424B3AFFB4}
static const GUID <<name>> =
{ 0xc62f1021, 0xe130, 0x42bc, { 0xa2, 0x6b, 0x29, 0x42, 0x4b, 0x3a, 0xff, 0xb4 } };

The 0x4... for the third field indicates something about these being random
one, not using times or device IDs.  Generating sequences is apparently now
frowned upon.


ADDITION [2026-01-18]:
  The use of various Windows.h defines and types is problematic here.  I would
  like something more at the essential C Language level.  I get to do that,
  I'm not actually using the Windows COM stuff, just using the model.  I can
  use the last byte (or even nibble) for oFrugal GUIDs.  The idea is to leave
  the ones retained from Microsoft, such as IID_IUnknown alone. Whatever lower
  digits need to be kept from those IIDs will be kept for those identifiers.
  Then I will navigate on the nibble, verify that the supplied GUID matches
  the full one we support, and flunk all the others.

  We get particular nibble values for oMiser GUIDs by generating random ones
  until the desired number shows up.  This will give us 16 slots to start
  with, We may never need that many, so playing it safe.  This should
  provide enough if we end up versioning any interfaces.  I am reserving
  32 to be safe, expecting that old code wouldn't care.  In that respect,
  the 16-slot table is probably too much also. We don't have to generate
  any more than actually needed.  And we can always expand to 32 when
  needed.

SOURCES

[Rogerson1997]
    Rogerson, Dale.  Inside COM. Microsoft Press (Redmond, WA: 1997).  ISBN
    1-57321-349-8.  <https://orcmid.github.io/bib/progsys.htm#Rogerson1997>.

Microsoft Learn
    Component Object Model (COM) Portal.  English version accessed at
    <https://learn.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal>
    on 2026-01-15, with complete 2020-08-21 windows-win32-com.pdf (56.274 MB
    3,738 pages) downloaded.


*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                     Copyright 2026 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 ATTRIBUTION

   Hamilton, Dennis E. oMiser Use of COM Interfaces.  Text file version 0.0.2
   dated 2026-01-17, available on the Internet as a version of
   <https://github.com/orcmid/miser/blob/master/devLab/oMiser/GUID.txt>.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

NOTES AND TODOS

 * FIND AND COMPLETE THE LIST OF THE FIRST 32 OLE_GUIDs

 * I need to figure out aggregation and other ways of combining interfaces
   and the underlying objects.  I might not need it though.


*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 0.0.2 2026-02-02T21:08Z Rerranging around known OLE GUIDs
 0.0.1 2026-01-18T21:58Z Expand on reserving a GUID block
 0.0.0 2026-01-17T00:28Z Initial draft on COM

                          ***** end of COM.txt *****

COM.txt 0.0.7                       UTF-8                          2026-01-23
*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                                 OMISER CODE

                       OMISER USE OF COM INTERFACES
                       ============================

    It is expected that oMiser will be created and usable via in-process
    COM interfaces, usable in C and C++ languages.  Whether or not that
    becomes the official API, techniques for encapsulation and hiding of
    implementation details will be featured in the chosen API.

    The intention is to provide a portable object-oriented technique for
    operating on any platform supporting standard C/C++ languages.  The
    COM-specific (and Microsoft-ish) development will be relied upon,
    rather than use of variant COM-like approaches that have arisen as
    alternatives.  Instead, the published and XOpen-adopted specification
    will be adhered to.

Potential Interfaces

    These interfaces are likely, or potentially available, so we need to
    watch how IIDs are contrived to allow rapid determination and validation
    of a supplied IID to QueryInterface.

             IUnknown  because that's always available, 0x00

          IDataObject  ways to access a data object (unlikely)

      IPersistStorage  for saving the state of an object in a storage
                       structure

       IPersistStream  another way to save the state of an object

         IPersistFile  and the usual way

    * EDITOR NOTE: These do not all seem to be identified in the near-original
      list of defined interface GUIDs.  I need to get on top of that.

    None of this is obligatory, and there is no intention to (expose or
    rely upon) COM creation of Class Factories and Class Factory creation of
    class instances.  This does require that there is a simple function to
    create a single oMiser instance.  It might not be OK to create more than
    one in a single process.

    It appears that there should be only one "object" that is all of oMiser,
    even though there are multiple interfaces.  I can also imagine there
    being some form of separation, because we can envision there being
    separation of the MOb something abut the structure separate individual
    ob-cells.  I'm going to leave that all here for now and resolve it as
    there is more effort on the code.

    CRUCIAL: One problem with COM objects: They are not movable, because while
       there are reference counts, it is not known where the references are
       and it is not expected that could be known.  So ob-cells on the stack
       cannot be moved if they are reference counted.  This suggests that
       ob-cells on the stack are not reference counted, they are treated
       differently as semi-transient entities until that is not the case and
       the object must be swept.  It may be that an ob-cell should not have an
       interface while it is on the stack until it is moved to the heap.
       It might be necessary to use the heap because of how C++ handles these.
       Then the question is, how can that work.
          That ¶ must hold should be a clue. ob-cells can only refer to
       ob-cells older than themselves.  And because ¶ is indefinite between
       individuals, we must deal with individuals differently to establish
       uniqueness of individuals and that means they are not on the stack.
       So synthetics (and bindings) are automatically swept, because the
       defining ob must be made "older."  So there needs to be a "persisting"
       mechanism, which smells like a Cheney to a new location.  But it
       preserves ¶ between the synthetic and its definition.  And then
       reference counting has to work, which is interesting.  So it could be
       that ob-cells on the stack are not reference counted and reference
       counting only happens on being persisted.  This looks like we are
       dealing with anonymity of ob-cells.  It seems that individuals are not
       anonymous and that might also be true of a result delivered to an app
       until that result is discarded.  If not anonymous, it must have a
       reference count of 1 at that point.
          We may be ignoring the impact of a reference being held by a parser,
       as for the oFrugal REPL.  I am presuming these are manageable, but
       I'm nervous about that.  Whatever the solution is, it must work for
       other external users of the oMiser API.  So most of this hand-wringing
       is going to be about obs not exposed to the external world.
          I am feeling very fragile here, and I definitely need to understand
       flyweights and tear-offs mentioned in [Box1998].

    In [Box1998: Appendix A] there is a discussion of flyweight objects as a
    variation of Crispin Goswell's tearoff technique.  The COM Programmer's
    Cookbook is no longer available at microsoft.com, so I need to find
    something better.  Tear-Off Interfaces are described at
    <http://www.369o.com/data/books/atl/0321159624/ch06lev1sec4.html> in
    ATL Internals: Working with ATL 8, Second Edition. Chapter 6,
    <http://www.369o.com/data/books/atl/>.
    There is a copy of Crispin's article at Wishfly's blog on CSDN.
    <https://blog.csdn.net/wishfly/article/details/1116343>.  I have failed
    to capture it in any form. I'm also uncertain that this makes any
    difference.  I'm uncertain about what is being saved.  I still have to
    find a way to use tiny objects easily, even if it is only under the
    covers of the COM-level interfaces.

SOURCES

[Box1998]
    Box, Don.  Essential COM.  Addison-Wesley (Reading MA: 1998).  ISBN
    0-201-63446-5. <https://orcmid.github.io/bib/progsys.htm#Box1998>

[Rogerson1997]
    Rogerson, Dale.  Inside COM. Microsoft Press (Redmond, WA: 1997).  ISBN
    1-57321-349-8.  <https://orcmid.github.io/bib/progsys.htm#Rogerson1997>.

[Microsoft2020]
    Component Object Model (COM) Portal.  English version accessed on
    2026-01-15.  See <https://orcmid.github.io/bib/authors.htm#Microsoft2020>.

Wikipedia
    IUnknown.  Article at <https://en.wikipedia.org/wiki/IUnknown>. Accessed
    on 2026-01-18T22:04Z.  This article describes the key aspects of IUnknown
    and the rules for it on all interfaces (all inheriting from IUnknown).

[Microsoft1995]
    The Component Object Model Specification 0.9 (draft). October 24, 1995.
    See <https://orcmid.github.io/bib/authors.htm#Microsoft1995>.




*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                     Copyright 2026 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 ATTRIBUTION

   Hamilton, Dennis E. oMiser Use of COM Interfaces.  Text file version 0.0.7
   dated 2026-01-23, available on the Internet as a version of
   <https://github.com/orcmid/miser/blob/master/devLab/oMiser/COM.txt>.

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

NOTES AND TODOS

 * Find the original COM specification.  I am viewing that specification in
   separate Work 6 files per chapter.

 * I HAVE A PROBLEM: It appears that strings are communicated to and from
   COM Interface methods in Unicode (wchar_t) all of the time.  I had not
   intended to do that, and I need to see if that is necessarily the case.
   I prefer to use UTF-8, but that does create problems at times.  I also
   need to know whether BSTRs are intended, are really just pure (wchar_t)
   with u0000 terminators and UTF-16LE.  There is also a conflict with
   Linux/Unix, which use 32 bits and UTF-32 encoding.  One feature of BSTRs
   is there reliable remote communication.  Also, the way they are pointed
   into makes them useful as simply null-terminated wchar_t vectors.  I'm
   still waffling about all of this.  I need to figure it out by the time
   I provide MOb interfaces.

 * Whatever the choice, I need to figure out the communication of text
   parameters (i.e., literals) to and from oFrugal, and that will matter for
   the way terminal is handled also.  There is a non-trivial impact on the
   display of canonical-form literals in oFrugal STDOUT delivery.

 * I also don't want to be wedded to wchar_t for stdout and output to files.
   UTF-8 is definitely more appealing.  I need to get on top of that.

 * I need to describe the oMiser scheme for a block of GUIDs and their
   systematic usage on versions of interfaces.  [dh:2026-01-21 I have a
   solution using a single nibble (16 0-F values) and I'll generate random
   guids until I get the series I want, apart from those take by standard
   COM GUIDs for Interfaces I might also support.  It might be *really*
   safe to choose 32, with the expectation of there never being a need for
   that many, even with versioning of interfaces (maybe).]

 * I need to figure out aggregation and other ways of combining interfaces
   and the underlying objects.

 * I definitely need the scheme by which both C and C++ rendition of the
   binary-compatible interfaces is handled. [dh:2026-01-21 It seems that
   the choice of calling sequence is relevant, since COM expects a particular
   way arguments are pushed on the stack sort-of right-to-left. Also, only
   the caller can release the parameter list from the stack, because
   technically, only the caller knows how many are supplied.]

 * Must test all of this at the binary level using both C++ generation of
   interfaces and the same via C Language explicit methods.

 * I need a way to confirm that calls and implementations are with the same
   version of oMiser COM objects.  I also want to deal at run-time with
   agreements on versions to the degree that matters.  This should get
   handled at ofEstablish, I think.  Smells like a secret hand-shake though.

 * And I need to know how many classes we're talking about.

 * I had an introduction to COM that had code for such things as IUnknown
   that was in Clean C (although there was a bug in AddRef/Release not
   being atomic).

*---|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 0.0.7 2026-01-23T23:27Z Fretting over tear-off interfaces
 0.0.6 2026-01-23T18:14Z Cleanup cross-referencing [Microsoft1995] and
       [Microsoft2020]
 0.0.5 2026-01-23T17:20Z Handwringing about reference counting and ¶
 0.0.4 2026-01-23T00:11Z Add [Box1998] and [Microsoft1995]
 0.0.3 2026-01-22T02:50Z Struggling still, pondering BSTRs too.
 0.0.2 2026-01-19T21:59Z More ponderings
 0.0.1 2026-01-18T23:15Z Note on locating a 1995 specification
 0.0.0 2026-01-15T17:55Z Initial draft on COM

                          ***** end of COM.txt *****

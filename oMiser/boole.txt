boole.txt 0.0.8                      UTF-8                       dh:2018-11-25
----|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                           The Miser Project Code
                           ======================

        <https://github.com/orcmid/miser/blob/master/oMiser/boole.txt>


     INTERPRETATION OF BOOLEAN ALGEBRAS IN THE ‹ob› MODEL OF COMPUTATION
     -------------------------------------------------------------------

        Boolean Algebras have rich application in connection with digital
        computation.

        For oMiser, enough Boolean Algebra theory is presented to illuminate
        important representation and interpretation features of other
        mathematical structures in ‹ob›.  Interpretations in ‹ob› will
        thereby have representation-preserving computational interpretations
        that are directly available in the ‹ob› computational model.

                              CONTENT

              1. MATHEMATICAL STRUCTURES
                 Abstract theories of Boolean Algebras in the manner of
                 obtheory although at a different level of abstraction

                 1.1 Notation and Basic Operations
                 1.2 Basic Constraints
                 1.3 Additional Characteristics
                 1.4 Interpretations

              2. ‹bp› REPRESENTATION

                 2.1 Unique Representation
                 2.2 Notable Qualities
                 2.3 ‹bp› Interpretation in ‹ob›
                 2.4 Domain-Restriction Consequences
                 2.5 Domain-Relaxation Equivalence

              3. ‹ba› REPRESENTATION

                 3.1 Concrete Representation
                 3.2 Boolean-Vector Structures
                 3.3 Concrete Boolean-Vector Interpretation
                 3.4 ‹ba› Interpretation in ‹ob›

              4. NOTES AND REFERENCES
                 Sources of further details and theoretical work concerning
                 Boolean Algebras and computational matters

 1. MATHEMATICAL STRUCTURES

    Two mathematical structures are introduced in the same manner as for ‹ob›.

    ‹ba› = 〈Ba,Baf,Bat〉
    ‹bp› = 〈Bp,Bpf,Bpt〉

    The logical theories Bpt and Bat are applications of First Order Logic
    with = (FOL=) using the notation introduced in Section 1 of obtheory.txt,
    <https://github.com/orcmid/miser/blob/master/oMiser/obtheory.txt>.

 1.1 Notation and Basic Operations

    The ‹bp› domain of discourse, Bp, consists of exactly two distinguished
    entities.

       ⊤ (nickname "top")
       ⊥ (nickname "bot")

    The ‹ba› domain of discourse, Ba, is a finite set having at least two
    distinct members, two of which are distinguished as ⊤ and ⊥, respectively.

    The additional basic notions consist of a small number of functions
    typically expressed as operations.

        ~ x  "comp" x, signifies the complement of x

      x ∩ y  x "cap" y also known as the meet of x and y

      x ∪ y  x "cup" y also known as the join of x and y

      x ∸ y  x "sep" y is x ∪ y excluding x ∩ y, also known as the symmetric
             difference, that which is separate between x and y, if anything.

    In addition to equality, there is also an ordering relation,

      x ⊆ y  x "sub" y, comparable to the subset relation among sets.

    To simplify expressions and reduce parentheses, the above listing is
    taken as an order of precedence, from strongest to weakest.  That is

        x ∩ ~ y ∪ ~ x ∩ y = (x ∩ (~ y)) ∪ ((~ x) ∩ y)

 1.2 Basic Constraints

    The basic conditions on all ‹ba› structures are presented in terms of
    axioms, arrangements that hold whatever the domain of discourse, Ba,
    happens to be and however the operations are defined in satisfaction
    of these constraints.

    Ba1. Commutativity
         x ∪ y = y ∪ x
         x ∩ y = y ∩ x

    Ba2. Identity
         x ∪ ⊥ = x
         x ∩ ⊤ = x

    Ba3. Distributivity
         x ∪ (y ∩ z) = (x ∪ y) ∩ (x ∪ z)
         x ∩ (y ∪ z) = (x ∩ y) ∪ (x ∩ z)

    Ba4. Complements
         x ∪ ~ x = ⊤
         x ∩ ~ x = ⊥

    Ba5. Subordination
         x ⊆ y ⇔ x = x ∩ y

 1.3 Additional Characteristics

    The following are consequences of the basic constraints.  They are
    applicable to any Boolean Algebra structure ‹ba› with distinguished
    domain Ba and definite basic operations satisfying Ba1-Ba5.

    Ba6. Associativity
         x ∪ (y ∪ z) = (x ∪ y) ∪ z
         x ∩ (y ∩ z) = (x ∩ y) ∩ z

    Ba7. Absorption
         x ∪ (x ∩ y) = x
         x ∩ (x ∪ y) = x

    Ba8. Unique Complement Pairs
         x = ~ ~ x
         x ≠ ~ x

    Ba9. Separation (definition)
         x ∸ y = x ∩ ~ y ∪ ~ x ∩ y

    Ba10. Well-Ordering
         ⊥ ⊆ y (hence "bot")
         x ⊆ ⊤ (hence "top")

    Ba11. The number of members in the domain of discourse Ba is even and a
         power of 2.

 1.4 Interpretations

    The structures, ‹ba› and the special case ‹bp› are highly abstract.
    The only requirement for representing any ‹ba› is to distinguish the
    (finitely) enumerable members of the domain of discourse in some manner;
    then represent basic functions such that all of the basic conditions
    are satisfied.

    Boolean Algebra structures do not solve all problems.  Even if such
    a structure can be imposed, it might not be particularly interesting or
    useful.  One flavor of Boolean Algebra that is known to be extremely
    valuable for work in logic and in computation is the simple case, ‹bp›.


 2. ‹bp› REPRESENTATION

 2.1 Unique Representation

    Given definite Bp = {⊥, ⊤}, the basic constraints are uniquelly satisfied
    by the functions represented here as bp.comp, bp.meet, bp.join, etc.

    bp.comp(⊥) = ⊤
    bp.comp(⊤) = ⊥

    bp.meet(⊤, x) = x
    bp.meet(⊥, x) = ⊥

    bp.join(⊤, x) = ⊤
    bp.join(⊥, x) = x

    bp.sep(⊤, x) = bp.comp(x)
    bp.sep(⊥, x) = x

    bp.sub(⊤, ⊤)
    bp.sub(⊥, x)

 2.2 Notable Qualities

     * Verification of a computational interpretation of Ba1-Ba10 by
       exhaustive testing is feasible.

     * All effectively computable functions, bp.f(x1, x2, ..., xn) in Bpf are
       representable via Bpt using only bp.comp, bp.meet, and bp.join
       operations along with equality.

     * Propositions of the form bp.f(x1, x2, ..., xn) = ⊤ correspond to
       propositional logic assertions s(p1, p2, ..., pn) by rewriting the Bt
       representation of bp.f such that ~ x becomes ¬ p, x ∩ y becomes p ∧ q,
       x ∪ y becomes p ∨ q, and x ∸ y becomes ¬ (p ⇔ q), the latter also
       known as exclusive-or.

     * The form bp.f(x1, x2, .., xn) is satisfiable if there is an assignment
       of {⊥, ⊤} values to individual xi such that bp.f(x1, x2, .., xn) = ⊤.
       The determination of satisfiability from the representation of bp.f can
       grow exponentially in the worst case as the number of variables
       increases.  Whether the worst case cannot be improved figures in an
       important conjecture (P ≠ NP) concerning computational complexity.

 2.3 ‹bp› Interpretation in ‹ob›

    A straightforward interpretation of ‹bp› in ‹ob› is by choosing any two
    distinct obs as ⊥ and ⊤ and matching representation of the unique ‹bp›
    functions with functions having corresponding representations in ‹ob›.

           ‹bp› notion (in Bpt)          an ‹ob› interpretation (in Ot)

              ⊥                            ob.NE.bp.bot = ob.NIL
              ⊤                            ob.NE.bp.top = ob.e(ob.NIL)
              bp.comp(x)                   ob.NE.bp.comp(x)
              bp.meet(x, y)                ob.NE.bp.meet(x, y)
              bp.join(x, y)                ob.NE.bp.join(x, y)
              bp.sep(x, y)                 ob.NE.bp.sep(x, y)
              bp.sub(x, y)                 ob.NE.bp.is-sub(x, y)
              x = y                        x = y

    supposing identification of sequence NE = [ob.NIL, ob.e(ob.NIL)] with
    the corresponding sequence [⊥, ⊤].

    Representation of the given ‹ob› interpretation can be accomplished
    directly.  Simply rewrite the unique representation (2.1) in Ot such that
    each occurrence of "bp" in the formulation is written "ob.NE.bp".
    The validity of the interpretation is direct.

    The elaborate namings, such as ob.NE.comp, reflect the specific
    interpretation based on the sequence NE, emphasizing that there are any
    number of distinct interpretations of ‹bp› in ‹ob›.

 2.4 Domain-Restriction Consequences

    Whereas the ‹bp› domain of discourse has exactly two mathematical
    entities, that is not the case for ‹ob›.  Carrying over the Bpt function
    representations of ‹bp› functions to corresponding representations in
    ‹ob› leads to partial functions in Of, ones undefined/ill-defined when an
     operand is neither an interpretation of ⊥ nor of ⊤.  That is no such
    difficulty as long as operands are confined to the interpretations.

    The undefined cases confound computational interpretations where direct
    lack of definition interferes with reasoning about computations and also
    raises questions about what operational behavior must be introduced in
    the case of computational-interpretation infractions.

 2.5 Domain-Relaxation Equivalence

    Alternatively, consider ob.NE.bp.comp(x), ..., ob.NE.bp.sub(x, y) with
    these representations:

         ob.is-individual(x) ⇒ ob.NE.bc.comp(x) = ob.e(ob.NIL)
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.comp(x) = ob.NIL

         ob.is-individual(x) ⇒ ob.NE.bc.meet(x, y) = x
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.meet(x, y) = y

         ob.is-individual(x) ⇒ ob.NE.bc.join(x, y) = y
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.join(x, y) = x

         ob.is-individual(x) ⇒ ob.NE.bc.sep(x, y) = y
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.sep(x, y) = ob.NE.bc.comp(y)

         ob.is-individual(x) ⇒ ob.NE.bc.sub(x, y)
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.sub(y, x)

    Under restriction of all operands to members of NE, the previous interpre-
    tation (2.3) is satisfied under domain restriction, just as in (2.4).

    This relaxed ‹ob› representation has the interesting quality that any
    individual is an interpretation of ⊥ and any non-individual is an
    interpretation of ⊤.  In this case we can consider ob.NIL to be the
    canonical form for interpretation of ⊥ and ob.e(ob.NIL) can serve as the
    canonical form for interpretation of ⊤.  The canonical form of an ob x in
    this interpretation is uniquelly determined by

         ob.NE.bp.cf(x) = ob.NE.bp.comp(ob.NE.bp.comp( x )).

    We can now remove the domain restriction by simply replacing the ‹ob›
    interpretation of x = y in (2.3) with

                    ob.NE.bp.cf(x) = ob.NE.bp.cf(y).

    This alternative effectively partitions the obs into two equivalence
    classes, one of all individuals and the other of everything else, and
    it is the classes that are interpreted as ⊥ and ⊤, respectively.

    Generalizations that preserve constraints while simplifying the
    formulation can be seen as a form of mathematical engineering.  Such
    approaches arise in the generalization of computational interpretations
    where the simplicity is important for understanding of validity and also
    improvement/simplification of operational performance.

    After [Forster2003], an interpretation where "="s correspond is termed
    an implementation.  When "="s do not correspond directly, but there is a
    corresponding representation in the interpretation, the interpretation is
    known as a simulation.


 3. ‹ba› REPRESENTATION

    When the ‹ba› = 〈Ba,Baf,Bat〉 domain of discourse, Ba, consists of more
    than two distinct members, finding a representation is not immediately
    obvious, in contrast with the handy representation of ‹bp› (section 2.1).
    ‹ba› representation depends on identification of the members of domain Ba
     and representing comp, join, and meet in Bat such that the basic
     constraints are satisfied (section 1.2).

    The mathematical theory of Boolean Algebras provides an assurance that
    every Boolean Algebra is isomorphic to what is known as a concrete
    Boolean Algebra [Wikipedia2018a].  By isomorphic is meant, here, that
    interpretation of one in the other works in both directions, without
    domain restriction.

    Having representations of concrete Boolean Algebras achieves ready
    availability of computational interpretations for those and also whatever isomorphic ‹ba› representations that are identified.

 3.1 Concrete Representation

    We define ‹bn› = 〈Bn,Bnf,Bnt〉, with n a natural number, to be a Concrete <ba> structure as follows.

    The number of distinguished members in the domain of discourse, Bn, is
    even and a power of two, symbolized 2^n.

    Choose a set of n distinct entities, An = {a1 ,a2, ..., an}.  Let Bn
    consist of all of the subsets of the set An, inclusive.  The empty subset
    corresponds to ⊥; the full (sub)set corresponds to ⊤.

    The operations of comp, meet, and join are then represented by the set-
    theoretical domain-relative difference, set intersection, and set union,
    respectively.

    For example, if n = 1, A1 = {a1} then B1 has 2 members: { } (the empty
    set) and {a1} the entire set.  Taking ⊥ = { } and ⊤ = A1, ‹b1› is
    isomorphic to ‹bp›.

    When n = 2 and A2 = {a1, a2}, B2 has 4 members:
         ⊥ = { }, {a1}, {a2}, {a1, a2} = ⊤

    Corresponding set-theoretic representations apply as n increases.

    For any ‹ba› where Ba has 2^n members, there must be a correspondence
    between those members and the members of Bn in structure ‹bn› such that
    however comp, meet, and join are represented in that ‹ba›, those
    functions corresponding to the comp, meet, and join of ‹bn›.  This is
    an interpretation in ‹bn› and there will be an appropriate interpretation
    of the ‹ba› equality as well, providing an implementation or a simulation
    as the case may be.

    Establishment of isomorphism between a ‹ba› and a ‹bn› constitutes an
    interpretation of the ‹ba› in ‹bn›, and vice versa.  A computational
    interpretation of one is, thereby, a computational interpretation of the
    other.  It is profitable to focus on concrete representations for this
    purpose.

 3.2 Boolean-Vector Structures

    The structure ‹bvn› = 〈Bvn,Bvnf,Bvnt〉, with n a natural number is a
    Boolean Algebra with representation as follows.

    The domain, Bvn, consists of all sequences [v1, v2, ..., vn], known as
    n-tuples, where each vi is a member of the structure ‹bp› = 〈Bp,Bpf,Bpt〉
    domain Bp.  By convention, we record each vi as 0 for ⊥ and as 1 for ⊤.

    The Boolean Algebra representation of ‹bvn› is accomplished as follows.

        ⊥ identifies [0, 0, ..., 0], with n places, in Bvn
        ⊤ identifies [1, 1, ..., 1] similarly

        [x1, x2, ..., xn] = [y1, y2, ..., yn]
           ⇔ x1=y1 ∧ x2 = y2 ∧ ... ∧ xn = yn

        bvn.comp([x1, x2, ..., xn])
           = [bp.comp(x1), bp.comp(x2), ..., bp.comp(xn)]

        bvn.join([x1, x2, ..., xn], [y1, y2, ..., yn])
           = [bp.join(x1, y1), bp.join(x2, y2), ... bp.join(xn,yn)]

        bvn.meet([x1, x2, ..., xn], [y1, y2, ..., yn])
           = [bp.meet(x1, y1), bp.meet(x2, y2), ... bp.meet(xn,yn)]

        bvn.sep([x1, x2, ..., xn], [y1, y2, ..., yn])
           = [bp.sep(x1, y1), bp.sep(x2, y2), ... bp.sep(xn,yn)]

        bvn.sub(X, Y) ⇔ X = bvn.meet(X, Y)

    Here, each occurrence of "=" is based on the structure in which the
    operands are distinguished.  The use of 0 and 1 disambiguates the
    distinction of ⊥ and ⊤ with respect to the two structures, ‹bvn› and ‹bp›.

    In this representation, we have presumed the ability to pair corresponding
    elements of ordered sequences (n-tuples) with the same number of elements.
    For computational interpretation in ‹ob›, there will be additional rigor
    in that accomplishment.

 3.3 Concrete Boolean-Vector Interpretation

    ‹bvn›, thus represented (3.2), satisfies the necessary constraints (1.2)
    for constituting a Boolean ALgebra.  It is not a concrete Boolean
    Algebra insofar as there is no connection with subsets of sets.

    Isomorphism of every ‹bvn› with a concrete Boolean Algebra structure,
    ‹bn›, is simple and useful.

    For any distinguished set, An = {a1, a2, ..., an}, establish the sequence
    of those distinct elements, [an, ..., a2, a1].  Correspond each entity,
    Xj = [xjn, ..., xj2, xj1], in the ‹bvn› domain, Bvn, with a subset in the
    ‹bn› domain Bn as follows.

      * If xji = 1, then element ai is in the Xj-corresponding subset.
      * If xji = 0, then element ai is not in the Xj-corresponding subset.

    The ‹bvn› representations (3.2) are immediately interpreted in ‹bn› with
    entities of the same names and with correspondence of the ‹bvn› and ‹bn›
    "=".

    The situation can be visualized in a tabulation.

         an  a(n-1)  ...  a2  a1   An

          0     0    ...   0   0   X0 = ⊥
          0     0    ...   0   1   X1
          0     0    ...   1   0   X2
          0     0    ...   1   1   X3
                     ...
         xjn xj(n-1) ...  xj2 xj1  Xj
                     ...
          1     1    ...   0   0   X(2^n-4)
          1     1    ...   0   1   X(2^n-3)
          1     1    ...   1   0   X(2^n-2)
          1     1    ...   1   1   X(2^n-1) = ⊤

    All 2^n Xj are tabulated in the above scheme.  The elements, Xj of
    domain Bvn are strictly ordered alphabetically assuming 0 < 1.  The Xj
    are enumerated numbered in that sequence, starting from j = 0.

    Each column beneath an ai in the table represents an indicator function
    for the associated ai, specifying 1 where ai is in that Xj row's
    corresponding concrete-interpretation subset and specifying 0 when that
    is not the case.

    Writing the xi values in decreasing order left-to-right is convenient for
    enumerating the Xj by interpreting the Xj sequence as the number j in
    binary notation.  The result is a strict enumeration of the 2^n unique Xj.


 3.4 ‹ba› Interpretation in ‹ob›

    [tbd]


 4. NOTES AND REFERENCES

    The extension of an interpretation to equivalence classes is an appealing
    idiom for computational interpretations.  The specific relaxation in (2.5)
    is remaniscent of provision in LISP, with atom NIL taken as ⊥, and in C-inspired languages, with 0 taken as ⊥.  Anything else is taken as ⊤.

    Limitation of ‹ba› to a domain of discourse having at least two members
    and being finite is appropriate for consideration of computational
    interpretations for oMiser.  Although there are Boolean Algebras having
    unbounded domains, that is not considered here.

    Formulation of ‹ba› is an amalgam of the various treatments cited below.
    Symbols ⊤ and ⊥ are chosen to avoid the common use of 1 and 0 and
    confusion with interpretation as numbers and binary bits, despite the
    historical roots in [Boole1834] and the practical application to binary
    representations in digital computing [Knuth2011].

    Likewise, the symbols for Boolean operations are kept distinct from the
    logical connectives used throughout oMiser use of FOL= notation, hence the
    use of complement, meet, join, and sep symbols and certain frussiness in
    qualifying represented functions by the name of the particular structure
    being represented.  Notational separation facilitates recognition of correspondences without implying identity, avoiding for a time any tacit
    collapsing of separate notions together as if about the same (abstract)
    entities.

    [Boole1854]
        Boole, George.  An Investigation of the Laws of Thought: on which
        are founded the mathematical theories of logic and probabilities.
        Dover (New York: 1958), original 1854 edition reprinted with all
        corrections made within the text.  ISBN 0-486-60028-9

    [EncycMath2012]
        Boolean algebra.  2012-04-04 article accessed on the Internet at
        <https://www.encyclopediaofmath.org/index.php?title=Boolean_algebra&oldid=24193>.

    [Forster2003]
        Forster, Thomas.  Reasoning About Theoretical Entities.  World
        Scientific (New Jersey: 2003). ISBN 981-238-567-3

    [Knuth2011]
        Knuth, Donald E.  Zeros and Ones.  Section 7.1, pp. 47-280 in The Art
        of Computer Programming, Volume 4A: Combinatorial Algorithms, Part 1.
        Addison-Wesley (Upper Saddle River, NJ: 2011). ISBN 978-0-201-03804-0

    [Rosenbloom1950]
        Rosenbloom, Paul C. The Logic of Classes.  Chapter 1, pp. 1-27 in The
        Elements of Mathematical Logic.  Dover (New York: 1950).  ISBN
        0-486-60227-3 pbk.

    [Stoll1979]
        Stoll, Robert R.  Boolean Algebra.  Chapter 6, pp. 248-288 in Set
        Theory and Logic.  Dover (New York: 1979).  ISBN 0-486-63829-4

    [Wikipedia2018a]
        Boolean algebra.  2018-11-04 article accessed on the Internet at
        <https://en.wikipedia.org/w/index.php?title=Boolean_algebra&oldid=867188281>.

    [Wikipedia2018b]
        Boolean algebra (structure).  2018-11-06 article accessed on the
        Internet at <https://en.wikipedia.org/w/index.php?title=Boolean_algebra_(structure)&oldid=867568743>.


 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

                   Copyright 2018 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 TODO:

  * In 3.4 do a generic interpretation of ‹bvn› and then label the ‹bn›
    interpretation.

  * Not certain where is the best place to talk about the brittleness of ‹bn›
    interpretation, when the mappings are different sequences but not
    necessarily different sets.  Also, that these are *into* ob, not *onto*
    and there can be many disparate interpretations of the same ob become
    matters of note.

  * The fact that ‹b1› corresponds with ‹bp› and is not the same is useful
    to note.

  * Well-ordering will be important (?).  Does it matter that Boolean Algebras
    are well-ordered and computational-interpretation must correspond, or is
    this a red herring?

  * Define the indicator functions better.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 0.0.8 2018-11-25-10:31 Complete the bvn interpretation in bn.  Repair text
       flow and rework 3.3.
 0.0.7 2018-11-24-12:41 Expand ‹ba› representation to interpretation of
       Boolean-Vector Boolean Algebras in concrete Boolean algebras that can
       then represent any Boolean Algebra on a finite and distinguished
       domain of discourse.
 0.0.6 2018-11-22-12:12 More smoothing and addition of 3.1 on concrete ‹ba›
       representations.
 0.0.5 2018-11-21-11:10 Proofing corrections, text improvements, and revamping
       of section 2 to bring out the interpretation considerations more fully.
 0.0.4 2018-11-20-14:55 Manage TODOs. Complete section 2.  Wordsmith.
 0.0.3 2018-11-19-11:49 Refine in preparation for ‹bp› Interpretation in ‹ob›.
 0.0.2 2018-11-18-12:14 Expand and refine coverage to ‹bp› representation.
 0.0.1 2018-11-15-14:38 Manage TODOs. Replace ⨁ with ∸ for symmetric
       difference.  Draft essentials of structures ‹ba› and ‹bp›.  Add initial
       references.
 0.0.0 2018-11-13-10:38 Placeholder and boiler plate for bridging between
       Boolean Algebras and computational interpretations in ‹ob›.

                       *** end of boole.txt ***

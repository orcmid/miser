boole.txt 0.0.5                      UTF-8                       dh:2018-11-21
----|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                           The Miser Project Code
                           ======================

        <https://github.com/orcmid/miser/blob/master/oMiser/boole.txt>


     INTERPRETATION OF BOOLEAN ALGEBRAS IN THE ‹ob› MODEL OF COMPUTATION
     -------------------------------------------------------------------

        Boolean Algebras have rich application in connection with digital
        computation.

        For oMiser, enough Boolean Algebra theory is presented to illuminate
        important representation and interpretation features of other
        mathematical structures in ‹ob›.  Interpretations in ‹ob› will
        thereby have representation-preserving computational interpretations
        that are directly available in the ‹ob› computational model.

                              CONTENT

              1. MATHEMATICAL STRUCTURES
                 Abstract theories of Boolean Algebras in the manner of
                 obtheory although at a different level of abstraction

                 1.1 Notation and Basic Operations
                 1.2 Basic Constraints
                 1.3 Additional Characteristics
                 1.4 Interpretations

              2. ‹bp› REPRESENTATION

                 2.1 Unique Representation
                 2.2 Notable Qualities
                 2.3 ‹bp› Interpretation in ‹ob›
                 2.4 Domain-Restriction Consequences
                 2.5 Domain-Relaxation Equivalence

              3. ‹ba› REPRESENTATION
                 [tbd]

              4. NOTES AND REFERENCES
                 Sources of further details and theoretical work concerning
                 Boolean Algebras and computational matters

 1. MATHEMATICAL STRUCTURES

    Two mathematical structures are introduced in the same manner as for ‹ob›.

    ‹ba› = 〈Ba,Baf,Bat〉
    ‹bp› = 〈Bp,Bpf,Bpt〉

    The logical theories Bpt and Bat are applications of First Order Logic
    with = (FOL=) using the notation introduced in Section 1 of obtheory.txt,
    <https://github.com/orcmid/miser/blob/master/oMiser/obtheory.txt>.

 1.1 Notation and Basic Operations

    The ‹bp› domain of discourse, Bp, consists of exactly two distinguished
    entities.

       ⊤ (nickname "top")
       ⊥ (nickname "bot")

    The ‹ba› domain of discourse, Ba, is a finite set having at least two
    distinct members, two of which are distinguished as ⊤ and ⊥, respectively.

    The additional basic notions consist of a small number of functions
    typically expressed as operations.

        ~ x  "comp" x, signifies the complement of x

      x ∩ y  x "cap" y also known as the meet of x and y

      x ∪ y  x "cup" y also known as the join of x and y

      x ∸ y  x "sep" y is x ∪ y excluding x ∩ y, also known as the symmetric
             difference, that which is separate between x and y, if anything.

    In addition to equality, there is also an ordering relation,

      x ⊆ y  x "sub" y, comparable to the subset relation among sets.

    To simplify expressions and reduce parentheses, the above listing is
    taken as an order of precedence, from strongest to weakest.  That is

        x ∩ ~ y ∪ ~ x ∩ y = (x ∩ (~ y)) ∪ ((~ x) ∩ y)

 1.2 Basic Constraints

    The basic conditions on all ‹ba› structures are presented in terms of
    axioms, arrangements that hold whatever the domain of discourse, Ba,
    happens to be and however the operations are defined in satisfaction
    of these constraints.

    Ba1. Commutativity
         x ∪ y = y ∪ x
         x ∩ y = y ∩ x

    Ba2. Identity
         x ∪ ⊥ = x
         x ∩ ⊤ = x

    Ba3. Distributivity
         x ∪ (y ∩ z) = (x ∪ y) ∩ (x ∪ z)
         x ∩ (y ∪ z) = (x ∩ y) ∪ (x ∩ z)

    Ba4. Complements
         x ∪ ~ x = ⊤
         x ∩ ~ x = ⊥

    Ba5. Subordination
         x ⊆ y ⇔ x = x ∩ y

 1.3 Additional Characteristics

    The following are consequences of the basic constraints.  They are
    applicable to any Boolean Algebra structure ‹ba› with distinguished
    domain Ba and definite basic operations satisfying Ba1-Ba5.

    Ba6. Associativity
         x ∪ (y ∪ z) = (x ∪ y) ∪ z
         x ∩ (y ∩ z) = (x ∩ y) ∩ z

    Ba7. Absorption
         x ∪ (x ∩ y) = x
         x ∩ (x ∪ y) = x

    Ba8. Unique Complement Pairs
         x = ~ ~ x
         x ≠ ~ x

    Ba9. Separation (definition)
         x ∸ y = x ∩ ~ y ∪ ~ x ∩ y

    Ba10. Well-Ordering
         ⊥ ⊆ y (hence "bot")
         x ⊆ ⊤ (hence "top")

    Ba11. The number of members in the domain of discourse Ba is even and a
         power of 2.

 1.4 Interpretations

    The structures, ‹ba› and the special case ‹bp› are highly abstract.
    The only requirement for representing any ‹ba› is to distinguish the
    (finitely) enumerable members of the domain of discourse in some manner;
    then represent the basic functions such that all of the basic conditions
    are satisfied.


 2. ‹bp› REPRESENTATION

 2.1 Unique Representation

    Given definite Bp = {⊥, ⊤}, the basic constraints are uniquelly satisfied
    by the functions represented as bp.comp, bp.meet, bp.join, etc.

    bp.comp(⊥) = ⊤
    bp.comp(⊤) = ⊥

    bp.meet(⊤, x) = x
    bp.meet(⊥, x) = ⊥

    bp.join(⊤, x) = ⊤
    bp.join(⊥, x) = x

    bp.sep(⊤, x) = bp.comp(x)
    bp.sep(⊥, x) = x

    bp.sub(⊤, ⊤)
    bp.sub(⊥, x)

 2.2 Notable Qualities

     * Verification of a computational interpretation of Ba1-Ba10 by
       exhaustive testing is feasible.

     * All effectively computable functions, bp.f(x1, x2, ..., xn) in Bpf are
       representable via Bpt using only bp.comp, bp.meet, and bp.join
       operations.

     * Propositions of the form bp.f(x1, x2, ..., xn) = ⊤ correspond to
       propositional logic assertions s(p1, p2, ..., pn) by rewriting the Bt
       representation of bp.f such that ~ x becomes ¬ p, x ∩ y becomes p ∧ q,
       x ∪ y becomes p ∨ q, and x ∸ y becomes ¬ (p ⇔ q), the latter also
       known as exclusive-or.

     * The form bp.f(x1, x2, .., xn) is satisfiable if there is an assignment
       of {⊥, ⊤} values to individual xi such that bp.f(x1, x2, .., xn) = ⊤.
       The determination of satisfiability from the representation of bp.f can
       grow exponentially in the worst case as the number of variables
       increases.  That the worst case cannot be improved figures in an
       important conjecture (P ≠ NP) concerning computational complexity.

 2.3 ‹bp› Interpretation in ‹ob›

    A straightforward interpretation of ‹bp› in ‹ob› is by choosing any two
    distinct obs as ⊥ and ⊤ and matching representation of the unique ‹bp›
    functions with functions having corresponding representations in ‹ob›.

           ‹bp› notion (in Bpt)          an ‹ob› interpretation (in Ot)

              ⊥                            ob.NE.bp.bot = ob.NIL
              ⊤                            ob.NE.bp.top = ob.e(ob.NIL)
              bp.comp(x)                   ob.NE.bp.comp(x)
              bp.meet(x, y)                ob.NE.bp.meet(x, y)
              bp.join(x, y)                ob.NE.bp.join(x, y)
              bp.sep(x, y)                 ob.NE.bp.sep(x, y)
              bp.sub(x, y)                 ob.NE.bp.is-sub(x, y)
              x = y                        x = y

    supposing identification of sequence NE = [ob.NIL, ob.e(ob.NIL)] with
    the corresponding sequence [⊥, ⊤].

    Representation of the given ‹ob› interpretation can be accomplished
    directly.  Simply rewrite the unique representation (2.2) such that
    each occurrence of "bp" in the formulation is written "ob.NE.bp".
    The validity of the interpretation is direct.

    The elaborate namings, such as ob.NE.comp, reflect the specific
    dependence on the sequence NE, emphasizing that there are any number
    of distinct interpretations of ‹bp› in ‹ob›.

 2.4 Domain-Restriction Consequences

    Whereas the ‹bp› domain of discourse has exactly two mathematical
    entities, that is not the case for ‹ob›.  Carrying over the Bpt function
    representations of ‹bp› functions to corresponding representations in
    ‹ob› leads to partial functions in Of, undefined/ill-defined when an operand is neither an interpretation of ⊥ nor of ⊤.  That is no problem so long as the operands are confined to the distinct interpretations.

    The undefined cases tend to confound computational interpretations where
    such direct lack of definition confounds reasoning about computations.

 2.5 Domain-Relaxation Equivalence

    Alternatively, consider ob.NE.bp.comp(x), ..., ob.NE.bp.sub(x, y) with these representations:

         ob.is-individual(x) ⇒ ob.NE.bc.comp(x) = ob.e(ob.NIL)
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.comp(x) = ob.NIL

         ob.is-individual(x) ⇒ ob.NE.bc.meet(x, y) = x
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.meet(x, y) = y

         ob.is-individual(x) ⇒ ob.NE.bc.join(x, y) = y
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.join(x, y) = x

         ob.is-individual(x) ⇒ ob.NE.bc.sep(x, y) = y
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.sep(x, y) = ob.NE.bc.comp(y)

         ob.is-individual(x) ⇒ ob.NE.bc.sub(x, y)
       ¬ ob.is-individual(x) ⇒ ob.NE.bc.sub(y, x)

    Under restriction of all operands to members of NE, the previous interpre-
    tation (2.3) is satisfied, just as in (2.4).

    This relaxed representation has the interesting quality that any
    individual is an interpretation of ⊥ and any non-individual is an
    interpretation of ⊤.  In this case we can consider ob.NIL to be the
    canonical form for interpretation of ⊥ and ob.e(ob.NIL) can serve as the
    canonical form for interpretation of ⊤.  The canonical form of an ob x in
    this interpretation is uniquelly determined by

         ob.NE.bp.cf(x) = ob.NE.bp.comp(ob.NE.bp.comp( x )).

    We can now remove the domain restriction by simply replacing the ‹ob› interpretation of x = y in (2.3) with

                    ob.NE.bp.cf(x) = ob.NE.bp.cf(y)

    which holds whether or not domain restriction is maintained.

    This alternative effectively partitions the obs into two equivalence
    classes, one of all individuals and the other of everything else, and
    it is the classes that are interpreted as ⊥ and ⊤, respectively.

    After [Forster2003], an interpretation where "=" carries over is termed
    an implementation.  When "=" does not carry over directly, the
    interpretation is known as a simulation.


 3. ‹ba› REPRESENTATION
    [tbd]


 4. NOTES AND REFERENCES

    The extension of an interpretation to equivalence classes is an appealing
    idiom for computational interpretations.  The specific relaxation in (2.5)
    is remaniscent of provision in LISP, with atom NIL taken as ⊥, and in C-inspired languages, with 0 taken as ⊥.

    Limitation of ‹ba› to a domain of discourse having at least two members
    and being finite is appropriate for consideration of computational
    interpretations for oMiser.  Although there are Boolean Algebras having
    unbounded domains, that is not considered here.

    Formulation of ‹ba› is an amalgam of the various treatments cited below.
    Symbols ⊤ and ⊥ are chosen to avoid the common use of 1 and 0 and
    confusion with interpretation as numbers and binary bits, despite the
    historical roots in [Boole1834] and the practical application to binary
    representations in digital computing [Knuth2011].

    Likewise, the symbols for Boolean operations are kept distinct from the
    logical connectives used throughout oMiser use of FOL= notation, hence the
    use of complement, meet, join, and sep symbols.  Notational separation
    facilitates recognition of correspondences without implying identity.

    [Boole1854]
        Boole, George.  An Investigation of the Laws of Thought: on which
        are founded the mathematical theories of logic and probabilities.
        Dover (New York: 1958), original 1854 edition reprinted with all
        corrections made within the text.  ISBN 0-486-60028-9

    [EncycMath2012]
        Boolean algebra.  2012-04-04 article accessed on the Internet at
        <https://www.encyclopediaofmath.org/index.php?title=Boolean_algebra&oldid=24193>.

    [Forster2003]
        Forster, Thomas.  Reasoning About Theoretical Entities.  World
        Scientific (New Jersey: 2003). ISBN 981-238-567-3

    [Knuth2011]
        Knuth, Donald E.  Zeros and Ones.  Section 7.1, pp. 47-280 in The Art
        of Computer Programming, Volume 4A: Combinatorial Algorithms, Part 1.
        Addison-Wesley (Upper Saddle River, NJ: 2011). ISBN 978-0-201-03804-0

    [Rosenbloom1950]
        Rosenbloom, Paul C. The Logic of Classes.  Chapter 1, pp. 1-27 in The
        Elements of Mathematical Logic.  Dover (New York: 1950).  ISBN
        0-486-60227-3 pbk.

    [Stoll1979]
        Stoll, Robert R.  Boolean Algebra.  Chapter 6, pp. 248-288 in Set
        Theory and Logic.  Dover (New York: 1979).  ISBN 0-486-63829-4

    [Wikipedia2018a]
        Boolean algebra.  2018-11-04 article accessed on the Internet at
        <https://en.wikipedia.org/w/index.php?title=Boolean_algebra&oldid=867188281>.

    [Wikipedia2018b]
        Boolean algebra (structure).  2018-11-06 article accessed on the
        Internet at <https://en.wikipedia.org/w/index.php?title=Boolean_algebra_(structure)&oldid=867568743>.


 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

                   Copyright 2018 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 TODO:

  * Establish ‹ba› and see what we need to differ with respect to ‹bp›.

  * Well-ordering will be important (?)

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 0.0.5 2018-11-21-11:10 Proofing corrections, text improvements, and revamping
       of section 2 to bring out the interpretation considerations more fully.
 0.0.4 2018-11-20-14:55 Manage TODOs. Complete section 2.  Wordsmith.
 0.0.3 2018-11-19-11:49 Refine in preparation for ‹bp› Interpretation in ‹ob›.
 0.0.2 2018-11-18-12:14 Expand and refine coverage to ‹bp› representation.
 0.0.1 2018-11-15-14:38 Manage TODOs. Replace ⨁ with ∸ for symmetric
       difference.  Draft essentials of structures ‹ba› and ‹bp›.  Add initial
       references.
 0.0.0 2018-11-13-10:38 Placeholder and boiler plate for bridging between
       Boolean Algebras and computational interpretations in ‹ob›.

                       *** end of boole.txt ***

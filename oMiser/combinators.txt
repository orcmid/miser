combinators.txt 0.0.4                UTF-8                       dh:2018-02-21
----|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                           The Miser Project Code
                           ======================
                            
    <https://github.com/orcmid/miser/blob/master/oMiser/combinators.txt>

       REPRESENTATION OF COMBINATORS IN THE ‹ob› MODEL OF COMPUTATION
       --------------------------------------------------------------
              
    Combinators are important theoretical objects related to the lambda (λ)
    calculus.  Realization of combinators using oMiser demonstrates a form 
    of computational universality: expressing all of the computable functions
    over a given datatype, including ‹ob› and further datatypes represented 
    in ‹ob›.

    The key is having representations of combinators that are interpretation-
    preserving.  That is, they work fine in combining function-representing
    obs beyond those interpretable as combinators.  
    
    Development of combinator representations proceeds from the theory of
    combinators to the demonstration of interpretation-preserving utility.
    This provides a key component in demonstration that the oMiser obap.ap
    function is computationally universal.
        
 1. MATHEMATICAL STRUCTURE 

    1.1 Theory of Combinator Arithmetic, CA

    The account of [Rosenbloom1950] is adapted here.

    C0. For combinators x and y, | x y is the combinator formed by
        application of x to y.
    C1. For combinator x, x ≈ x.
    C2. For combinators x and y, x ≈ y ⇒ y ≈ x.
    C3. For combinators x, y, and z, x ≈ y ∧ y ≈ z ⇒ x ≈ x. 
    C4. For combinators x, y, a, and b, x ≈ y ∧ a ≈ b ⇒ | x a ≈ | y b.
    C5. S and K are combinators.
    C6. For combinators x, y, and z, ||| S x y z ≈ || x z | y z.
    C7. For combinators x and y, || K x y ≈ x.
    CE. For combinators x and y, if | x a ≈ | y a for all combinators, a,
        then x ≈ y.

    The logical notation is that used in obtheory.txt,
    <https://github.com/orcmid/miser/blob/master/oMiser/obtheory.txt>.
    
    This is not about ‹ob›.  The combinators are not obs.  Likewise, the
    application, | f x, is an application of combinators that yields
    combinators.  It must not be confused with the obap.ap of obaptheory,
    <https://github.com/orcmid/miser/blob/master/oMiser/obaptheory.txt>,
    where application is of the procedure encoded in one ob to the operand
    ob.

    The notation with "|" for application is an useful reminder that this
    application operation is in the realm of combinators.  It is convenient
    to omit leading "|" since they can be added automatically: the total 
    number of "|" must be one less than the number of terms in the 
    expression.  We can write

       S x y z for ||| S x y z
       K x y for || K x y
       x z | y z for || x z | y z

    The symbol "≈" is for equivalence of combinators.  This is distinct
    from the "=" equality relationship among obs.  Although "≈" is tantamount
    to an equality, that interpretation is avoided here.  It is unclear that 
    there are distinguished, unique mathematical entities for any combinator.
    We leave open the prospect that combinators might differ, although not in 
    terms of their equivalence under (CE).

    1.2 Useful Combinators

    It is known for CA that all combinators can be expressed in terms
    of combinators S and K alone  Some are so handy that there are constant
    names for them.  There are also equivalent λ-expressions, as noted.

      S x y z ≈ x z | y z
            S ≈ λx.λy.λz.( (x z)(y z) )

      K x y ≈ x   
          K ≈ λx.λy.x  
    
      I x ≈ x
        I ≈ S K K
          ≈ λx.x

      B f g x ≈ f | g x
            B ≈ S | K S K
              ≈ λf.λg.λx.( f(g x) )

      C f x y ≈ f | y x
            C ≈ S | D S | K K
              ≈ λf.λx.λy.( f(y x) )

      D f x g y ≈ f x | g y
              D ≈ B B
                ≈ λf.λx.λg.λy.( (f x)(g y) )

      T x f ≈ f x
          T ≈ C I
            ≈ λx.λf.( f x )

      W f x ≈ f x x
          W ≈ S S | S K
            ≈ λf.λx.( (f x) x )

    There are no combinator "constants" (e.g., S, K, or others) in these 
    λ-expressions and variables in the expressions are ones for which there 
    is an outer (preceding) λ form. This closed form of λ-expression is
    interchangeable with the notation for combinators of (1.1) in the 
    equivalences above.

    Precise rules for using λ-expression forms and reasoning about them
    are complicated by the use of variables.  For a typical explanation, see
    [Révész1988: 2.1].  Detailed descriptions are found on the Internet,
    e.g., <https://en.wikipedia.org/wiki/Lambda_calculus#Formal_definition>.
      
    In Miser Project usage, parentheses are retained in (closed) λ-expressions
    as shown above to avoid ambiguity between typical λ-calculus notations
    for applicative expressions and the Frugalese expressions having the same
    λ-calculus/combinatory-logic interpretations.
    
    1.3 What Combinator Is It?  

    Formally, all we can do is manipulate formulas of combinators in 
    ways that demonstrate two forms are equivalent.  To assess the nature
    of some combinator in achieving a particular applicative arrangement, 
    a simple approach consists of the following:

       * Given some combinator expression having only constants (such as
         B, K, and S) write the expression applied to a succession of 
         variables, a, b, c, ... .  Expand the expression wherever application
         of a constant combinator can be replaced by its equivalent form.  
         Stop application to variables once expansion leaves no constants 
         or when that is clearly not achievable.  
         
    For example, given | S K, expand via
         
             S K a b = K b | a b ≈ b.  

    In the case of S K a b, we see that S K a b ≈ b ≈ I b, and so by (CE)
    S K a ≈ I, for a any combinator, including K.

    Consider
                   B I a b  ≈  I | a b  ≈  a b.
    Then              B I a ≈ a
    by (CE), and        B I ≈ I 
    by (CE) as well.

    There is more difficulty determining what combinator | W W W might be.
    Substituting in | W a b ≈ | a b b simply yields | W W W and there is
    no progress to be made.  Additional exotic cases of practical importance
    are addressed in Section 3, below.

    1.4 The Power of Combinators

    Even in CA, where the only mathematical entities are the combinators, 
    whether expressed in a pure combinatory manner or with closed 
    λ-expressions, it is possible to represent all manner of data and
    operations on such data.  Such representations are found in  [Burge1975],
    [Révész1988: Chapters 3-4], and [Paulson1996].
      
    Fundamentally, the combinators and equivalent closed λ-expressions are
    all about ways of composing functions from other ones.  Although this
    can be employed indefinitely using combinators as the only entities, the
    capabilities of CA are also of practical use in composing applications
    of other types of functions, so long as those functions are compatible
    with the combinators applied to them.  That is, the application of 
    combinators can be employed in a manner that is indifferent to the nature
    of the other types of functions, using the same concrete realization of
    application, with all of the combinational power of combinators available.
    
    This power is exploited in the concrete representation of combinators via
    oMiser script obs.  Combinator representations applied to representations
    of other types of functions will lead to some valuable idioms in the 
    composition of oMiser applicative scripts from other, simpler ones.

 2. FUNCTIONAL TYPE AND INTERPRETATION PRESERVATION

    2.1 Functional Type

    The usual notation for functional type is used here.  We designate types
    using Greek letters.  

       f: α → β
       
    expresses that f is a function that, when applied to an operand of type α
    yields a result of type β.  The type of f is (α → β).

    In these terms, from inspection of the definitions, (1.2), we can infer
    the simplest functional types as follows

       K x y ≈ x
       x: α
       y: β
       K: α → (β → α)

      S x y z = x z | y z
      z: α
      y: α → β
      x: α → (β → γ)
      S: (α → (β → γ)) → (α → β) → (α → γ)

      I x ≈ x
      x: α
      I: α → α

      B f g x ≈ f | g x
      x: α
      g: α → β
      f: β → γ
      B: (β → γ) → (α → β) → (α → γ)

      C f x y ≈ f | y x
      x: α
      y: α → β
      f: β → γ
      C: (β → γ) → α → (α → β) → γ

      D f x g y ≈ f x | g y
      y: α
      g: α → β
      x: γ
      f: γ → (β → δ)
      D: (γ → (β → δ)) → γ → (α → β) → (α → δ)

      T x f ≈ f x
      x: α
      f: α → β   
      T: α → (α → β) → β

      W f x ≈ f x x
      x: α
      f: α → (α → β)
      W: (α → (α → β)) -> (α → β)      


 3. RECURSION AND ITS DIFFICULTIES


x. REFERENCES AND RESOURCES

   [Burge1975]
      Burge, William H.  Recursive Programming Techniques.  Addison-Wesley
      (Reading, MA: 1975).  ISBN 0-201-14450-6.  Although the approach starts
      with a functional-style, the interconnections and definability in terms
      of combinators and closed λ-expressions is worked up to in Chapter 1,
      with further refinement (and implementation matters) thereafter. 

   [Paulson1996]
      Pauson, Lawrence C.  ML for the Working Programmer, ed.2.  Cambridge 
      University Press (Cambridge: 1991, 1996).  ISBN 0-521-56543-X pbk. 
      Digging into the combinators, λ-calculus, and representation of other
      types as interpretations of λ-expressions occurs in Chapter 9, Writing
      Interpreters for the λ-Calculus, starting in section 9.5.

   [Révész1988]
      Révész, György E.  Lambda-Calculus, Combinators and Functional 
      Programming.  Cambridge University Press (Cambridge: 1988), ISBN
      0-521-345589-8.  The notational use of (f)(x)y for conventional f(x(y)),
      applicative f(x y) and combinator f | x y requires careful reading.  
      Chapter 3, Combinators and Constant Symbols, provides extensive examples
       also relevant to computational representations.  Section 2.4 provides
      a treatment of λ-expressions that can be adapted to the strict use
      in (1.2) here.

   [Rosenbloom1950]
      Rosenbloom, Paul C.  The Elements of Mathematical Logic.  Dover (New
      York: 1950).  ISBN 0-486-60227-3 pbk.  The notation for expressing 
      combinators (1.1 here) and the expression of CA are derived from 
      section III.4, Combinatory Logics. 

   [Scott1993]
      Scott, Dana S.  A Type-Theoretic Alternative to ISWIM, CUCH, OWHY.
      Theoretical Computer Science 121, 1-2 (December 1993), 411-440. At
      <https://www.sciencedirect.com/science/article/pii/030439759390095B>.
      The type-theoretic approach treats type as definite and distinguished
      even though the formalism is interpretable as polymorphic in the manner
      proposed here for the functional types of combinators.

   [Scott1977]
      Scott, Dana S.  Logic and Programming Languages. 1976 ACM Turing Award
      Lecture.  Comm. ACM 20, 9 (September 1977), 634-641.  PDF availabe at
      <http://delivery.acm.org/10.1145/1290000/1283932/a1976-scott.pdf>.  The
      discussion on semantic structures and function space is a valuable
      collateral on the use of monotonicity and continuity in [Scott1993],
      a paper originally circulated informally in 1969.
         
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

                   Copyright 2018 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 TODO:

  * Address the recognition of multiple expressions for the same combinator 
    and especially at the level of oMiser representation.

  * Find a combinator form for Y ≈ λy.(λx.y(x x) λx.y(x x) ) and verify in
    accordance with [Revesz1988: p.44].

  * Link to other materials of the Miser Project that explore some of these
    matters in greater detail.  Connect to combdemo.sml, and also work in
    Ycombinator (.txt or .sml?), and comblib.sml.

  * Introduce the notion of concrete entities with respect to representation
    via obs.


 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 0.0.4 2018-02-21-14:48 Introduce 2.1 on Functional Type; manage TODOs 
 0.0.3 2018-02-17-10:56 Polish and set the stage for the Y combinator.
 0.0.2 2018-02-13-10:00 Get past the Combinator Theory enough to talk about
       interpretation preservation.  Introduce λ-expressions.
 0.0.1 2018-02-11-21:10 Add section 1.1-1.2 In continuing development of
       the mathematical structure of combinators.
 0.0.0 2018-02-10-13:28 Placeholder and boiler plate for a description of the
       nature of combinators, the chosen representations, and the power of
       interpretation-preserving operation.

                   *** end of combinators.txt ***
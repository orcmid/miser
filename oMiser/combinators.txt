combinators.txt 0.0.10               UTF-8                       dh:2018-05-20
----|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                           The Miser Project Code
                           ======================

    <https://github.com/orcmid/miser/blob/master/oMiser/combinators.txt>

       REPRESENTATION OF COMBINATORS IN THE ‹ob› MODEL OF COMPUTATION
       --------------------------------------------------------------

    Combinators are important theoretical objects related to the lambda (λ)
    calculus.  Realization of combinators using oMiser demonstrates a form
    of computational universality: expressing all of the computable functions
    over a given datatype, including ‹ob› and further datatypes represented
    in ‹ob›.

    The key is having representations of combinators that are interpretation-
    preserving.  That is, they extend indifferently to combining function-
    representing entities beyond those interpretable as combinators.

    The challenge is oMiser being a concrete system in which applicative
    interpretation is not a formal matter but a computational procedure
    that yields a definite ob result, if any, on each obap.ap or obap.eval
    evaluation.  Achievement of combinator representations is required to
    fit that computational apparatus.

    Development of oMiser combinator representations proceeds from the theory
    of combinators through demonstration of interpretation-preserving utility.

    There is, thereby, exhibition of an important aspect of software
    engineering: successful intended interpretation of other, higher-order
    computational entities via functions over quite different, lower-level
    data structures, bridging between different levels of abstraction.

                                  CONTENT

              1. MATHEMATICAL STRUCTURE
                 An abstract theory in the manner of obtheory that
                 is at a powerful though not-so-grounded level of
                 abstraction

                 1.1 Theory of Combinator Arithmetic, ‹ca›
                 1.2 Useful Simple Combinators
                 1.3 What Combinator Is It?
                 1.4 The Power of Combinators

              2. FUNCTIONAL TYPE AND INTERPRETATION PRESERVATION
                 The important quality that, embodied in concrete
                 representations of combinators, extends to intended
                 interpretations of oMiser scripts as functions on
                 many types of computational entity

                 2.1 Functional Type
                 2.2 Interpretation Preservation by Functional Type
                 2.3 The Avenue to Concrete Interpretations
                 2.4 Restricted Interpretation as Types

              3. The oMISER UTILITY COMBINATOR IDIOMS
                 Demonstration of scripts that are equivalent to
                 combinators under a straightforward interpretation

                 3.1 Combinator Representation Constraints
                 3.2 Representing K, I, and S
                 3.3 Derived Utility Combinators B, C, D, T, and W

              4. RECURSION AND EXOTIC COMBINATORS
                 Achievement of recursive operation and conditional
                 evaluation in terms of combinators

                 4.1 Conditional Behavior
                 4.2 Y Combinator Interpretation
                 4.3 The Uβ Combinator and Truth Indifference

              5. REFERENCES AND RESOURCES
                 Sources of further details and theoretical work
                 behind the kind of functional programming that
                 oMiser affords

 1. MATHEMATICAL STRUCTURE

    1.1 Theory of Combinator Arithmetic, ‹ca›

    The account of [Rosenbloom1950] is adapted here.

    C0. For combinators x and y, | x y is the combinator formed by
        application of (operator) x to (operand) y.
    C1. For combinator x, x ≈ x.
    C2. For combinators x and y, x ≈ y ⇒ y ≈ x.
    C3. For combinators x, y, and z, x ≈ y ∧ y ≈ z ⇒ x ≈ x.
    C4. For combinators x, y, a, and b, x ≈ y ∧ a ≈ b ⇒ | x a ≈ | y b.
    C5. S and K are combinators.
    C6. For combinators x, y, and z, ||| S x y z ≈ || x z | y z.
    C7. For combinators x and y, || K x y ≈ x.
    CE. For combinators x and y, if | x a ≈ | y a for all combinators, a,
        then x ≈ y.

    The logical notation is that used in obtheory.txt,
    <https://github.com/orcmid/miser/blob/master/oMiser/obtheory.txt>.

    This is not about ‹ob›.  The combinators are not obs.  Likewise, the
    application, | f x, is an application of combinators that yields
    combinators.  It must not be confused with the obap.ap of obaptheory,
    <https://github.com/orcmid/miser/blob/master/oMiser/obaptheory.txt>,
    where application is of the procedure encoded in one ob, as operator, to
    the operand ob.

    The notation with "|" for application is an useful reminder that this
    application operation is in the realm of combinators.

    It is convenient to omit leading "|" since they can be supplied
    automatically: the total number of "|" must be one less than the number
    of terms in the expression.  We can write

       S x y z for ||| S x y z
       K x y for || K x y
       x z | y z for || x z | y z

    In text and some other places, at least one "|" is retained to signal
    that the expression is in ‹ca›, not ‹ob›.

    The symbol "≈" is for equivalence of combinators.  This is distinct
    from the "=" equality relationship among obs.  Although "≈" is tantamount
    to an equality in ‹ca›, that interpretation is avoided here.  It is
    unclear that there are distinguished, unique mathematical entities for
    combinators.  We shall skirt the question with "≈", accepting that there
    might be multiple but equivalent concrete interpretations in a
    computational model of ‹ca› and be content with that.

    1.2 Useful Simple Combinators

    It is known for ‹ca› that all combinators can be expressed in terms
    of combinators S and K alone (with certain reservations concerning
    concrete representation that will be addressed in further sections).

    Some derived combinators are so handy that there are constant names for
    them. There are also equivalent λ-expressions, shown below.

      S x y z ≈ x z | y z
            S ≈ λx.λy.λz.( (x z)(y z) )

      K x y ≈ x
          K ≈ λx.λy.x

      I x ≈ x
        I ≈ S K K
          ≈ λx.x

      B f g x ≈ f | g x
            B ≈ S | K S K
              ≈ λf.λg.λx.( f(g x) )

      C f x y ≈ f | y x
            C ≈ S | D S | K K
              ≈ λf.λx.λy.( f(y x) )

      D f x g y ≈ f x | g y
              D ≈ B B
                ≈ λf.λx.λg.λy.( (f x)(g y) )

      T x f ≈ f x
          T ≈ C I
            ≈ λx.λf.( f x )

      W f x ≈ f x x
          W ≈ S S | S K
            ≈ λf.λx.( (f x) x )

    In these λ-expressions there are no combinator "constants" (i.e, S, K, and
    others) and variables in the expressions are ones for which there is an
    outer (preceding) λ form. This closed form of λ-expression is inter-
    changeable with the notation for combinators of (1.1), as demonstrated
    with the equivalences above.

    Precise rules for using λ-expression forms and reasoning about them are
    complicated by the use of variables.  For a typical explanation, see
    [Révész1988: 2.1].  Detailed descriptions are found on the Internet,
    e.g., <https://en.wikipedia.org/wiki/Lambda_calculus#Formal_definition>,
    with more on ‹ca› at <https://en.wikipedia.org/wiki/Combinatory_logic>.
    A comprehensive treatment is in [Barendregt1981].

    Equivalent λ-expressions make the applicative structure more apparent,
    easier to express, and suggestive of intermediate forms.  That utility
    will be exploited later by introduction of a computationally-derived
    λ-abstraction via an oMiser script.

    Here, in Miser Project usage, parentheses are retained in (closed)
    λ-expressions as shown above to avoid any ambiguity in application order
    between typical λ-calculus notations for applicative expressions and the
    different unparenthesized construction of applications in Frugalese.  C.f.
    <https://github.com/orcmid/miser/blob/master/oMiser/ob-exp.txt>.

    1.3 What Combinator Is It?

    Formally, all we can do is manipulate formulas of combinators in
    ways that demonstrate two forms are equivalent.  To assess the nature
    of some combinator in achieving a particular applicative arrangement,
    a simple approach consists of the following:

       * Given some combinator expression having only constants (such as
         B, K, and S) write the expression applied to a succession of
         variables, a, b, c, ... .  Expand the expression wherever application
         of a combinator constant can be replaced by its equivalent defined
         form.  Stop application to variables once expansion leaves no
         combinator-constant symbols or when that is clearly not achievable.

       * An expansion can also go no further when not all of the arguments of
         a defined combinator are available, including when a variable of
         unknown definition is shown as the operator of an application.

    For example, given | S K, expand via

             S K a b = K b | a b ≈ b.

    In the case of | S K a b, we see that | S K a b ≈ b ≈ I b, and so by (CE)
    | S K a ≈ I for any combinator, a, including K.

    Consider
                   B I a b  ≈  I | a b  ≈  a b.
    Then              B I a ≈ a ≈ I a
    by (CE), and        B I ≈ I
    by (CE) as well.

    There is more difficulty determining what combinator | W W W might be.
    Substituting in | W a b ≈ | a b b simply yields | W W W and there is
    no progress to be made.  Additional exotic cases of practical importance
    are addressed in Section 4, below.

    1.4 The Power of Combinators

    Even in ‹ca›, where the only mathematical entities are the combinators,
    whether expressed in a pure combinatory manner or with closed
    λ-expressions, it is possible to represent all manner of data and
    operations on such entities.  Such representations are found in
    [Burge1975], [Révész1988: Chapters 3-4], and [Paulson1996].  [Scott2012],
    focusing on the λ-calculus view, sketches a variety of constructions and
    connections in mathematical logic and other theoretical mathematical
    approaches.  Some of these will be investigated later when oMiser
    representation of other schemes is assessed.

    Fundamentally, the combinators and equivalent closed λ-expressions are
    all about ways of composing functions from other ones.  Although this
    can be employed indefinitely presuming combinators as the only entities,
    the capabilities of ‹ca› are also of practical use in composing other
    types of functions, so long as those functions are compatible with the
    combinators applied to them.

    This power is exploited in the concrete representation of combinators via
    oMiser script obs in Section 3.  The bridge is via functional type and
    interpretation-preserving use of combinators and combinator-like entities.

 2. FUNCTIONAL TYPE AND INTERPRETATION PRESERVATION

    Despite ‹ca› having application as the only operation, and combinators as
    the only entities, there is another level of abstraction immediately
    available as a potential nterpretation: that of functional types.

    2.1 Functional Type

    The usual notation for functional type is used here, as in [Burge1975:1.2,Feferman1977:2.1, Scott1993:1].  We use Greek letters to signify
    arbitrary types.

       x: α
       f: α → β

    expresses that x is an entity of type α and f is a function that when
    applied to an operand of type α yields a result of type β.  The type of
    f is (α → β).  Types can be composed further by substitutions in that
    pattern.

    From inspection of the definitions, (1.2), we can infer the simplest
    functional types of well-known combinators as follows

       K x y ≈ x
       y: α
       x: β
       K: β → (α → β)

      S x y z = x z | y z
      z: α
      y: α → β
      x: α → (β → γ)
      S: (α → (β → γ)) → (α → β) → (α → γ)

      I x ≈ x
      x: α
      I: α → α

      B f g x ≈ f | g x
      x: α
      g: α → β
      f: β → γ
      B: (β → γ) → (α → β) → (α → γ)

      C f x y ≈ f | y x
      x: α
      y: α → β
      f: β → γ
      C: (β → γ) → α → (α → β) → γ

      D f x g y ≈ f x | g y
      y: α
      g: α → β
      x: γ
      f: γ → (β → δ)
      D: (γ → (β → δ)) → γ → (α → β) → (α → δ)

      T x f ≈ f x
      x: α
      f: α → β
      T: α → (α → β) → β

      W f x ≈ f x x
      x: α
      f: α → (α → β)
      W: (α → (α → β)) -> (α → β)

    2.2 Interpretation Preservation via Functional Type

    Functional types in ‹ca› reveal the extent to which a combinator can be
    indifferent to the functional interpretation of entities involving
    various types under the same system of application.

    The trivial case is when all of the type variables are replaced by the
    same specific type, whether CA or Ob.

    Combinators taken as interpretation-preserving of functional types, as
    here, are said to be polymorphic with regard to their accomodation of
    fixed types of operands and operators that satisfy their variable
    functional-type patterns.

    2.3 The Avenue to Concrete Interpretations

    The oMiser interpretation of ‹ca› is as follows.

     * The interpretation of |x y is as obap.ap(cx, cy) where cx and cy are
       the oMIser interpretations of combinators x an y, respectively.

    For the concrete computational mechanism of oMiser obap.ap, one can simply
    substitute Ob for all of the type variables, α, β, γ, δ.  There is
    similarity with ‹ca› in the sense that every ob has interpretation as an
    (Ob → Ob) type. That does not assure interpretation as a combinator
    under obap.ap, however.

    Having a script, ^cK interpretable as combinator K, it must be the case
    that, in oFrugalese notation,

      (^cK x) y = x

    so if x is interpretable as a combinator, that interpretation is
    preserved just as it is for x interpretable as an entity of any type,
    since it preserves the ob, x, and whatever interpretation that might
    be intended for it.  In this manner, ^cK interpretation as combinator K
    is satisfied and functional type is also honored.

    The ^-notation as part of a constant name is oFrugalese for a binding to
    a constant ob.  The names in the forms such as ^cK are adopted to signify
    oMiser representations of the corresponding combinator.

    Likewise, supposing there is a script, ^cS, such that, in oFrugalese,

      ((^cS x) y) z = (x z) (y z),

        ^cS: (α → (β → γ)) → (α → β) → (α → γ)

    works when x, y, and z have interpretation as combinators or as other
    types of entities consistent with the functional type of ^cS.  It is
    sufficient for ^cS operation to preserve the interpretations of x, y, and
    z and that those operand interpretations satisfy their role in the
    functional-type pattern (α → (β → γ)) → (α → β) → (α → γ).

    Here there are Ot "=" and definite computational results, yet preserving
    interpretation with regard to functional type.

    Representing combinators via scripts that provide interpretation-
    preserving concrete ob results is sufficient for modeling computational
    structures including ‹ca›.  We can describe this pervasive condition as
    quasi-combinatory.

    2.4 Restricted Interpretation as Types

    In ‹ca› there are only combinators and the application operation; in ‹ob›
    there are only obs, some primitive functions, and other functions on obs
    including application operations obap.ap and obap.eval.

    Within those respective theoretical structures, as given for oMiser,
    the notion of different functional types and different individual types
    is a higher level of abstraction based on achievement of intended
    interpretations, interpretations that are usually not satisfied by all
    operators and operands with respect to application. E.g, not every ob has
    interpretation as a combinator.  Similarly, certain interpretations of
    combinators (e.g., as predicates) do not extend to all ‹ca› combinators.

    For the oMiser representation of ‹ob›, the interpretation of an ob apart
    from being just an ob depends on some characterization that some obs
    satisfy and, presumably, others do not.

    To manifest a level of abstraction in which the specific functional types
    are satisfied, there must be some restraint to using obs that are computa-
    tional representations of and interpretable as individuals of specific
    functional types.  Maintaining the semblance involves restraints on the
    use of the computational entities (e.g., representations via obs) in a
    orchestrates computational procedures in satisfaction of the restricted
     interpretation(s).

    In the context of digital computation, the orchestration of available
    types in manifestation of other (higher-order) types is characteristic
    of computer software programming.  There are practices which are employed
    to engineer the layering of abstractions in dependable ways.

     A. Preserved interpretations.  Restraints are applied in the design,
        combination, and operation of scripts such that particular representa-
        tions are confirmed to be interpretable as particular types.  For
        example, the representation of combinators by obs that are used in
        accordance with the related functional types.  The demonstration that
        the abstraction is preserved is usually established externally and
        with computational tests that confirm satisfaction and preservation
        of particular-type semblance.

     B. Distinguished interpretations.  Having a computational means to
        discriminate entities that definitely satisfy a particular interpreta-
        tion from those that are not so distinguished.  This can be used by
        procedures to verify that their operands satisfy an intended
        interpretation of the procedure authors.

     C. Designated interpretations.  Providing some sort of decoration on
        entities that names or annotates the representations themselves.  This
        provides a strict labelling of a type interpretation for an entity.

    Typically, there are many ways to represent entities of some type, and
    it then becomes interesting to deal with (1) the different interpretations
    that a single computational entity might satisfy and (2) inter-operation
    with different representations of the same type.

    We use the oMiser idioms for combinators to launch Miser Project investi-
    gation of levels of computational abstraction and how computational means
    are applicable to manage and confirm representations and satisfaction of
    theoretical interpretations.

 3. oMISER UTILITY COMBINATOR IDIOMS

    3.1 Combinator Representation Constraints

    The conditions on the concrete representation of combinators via obs are

      * The application obap.ap(cf,cx) of ‹ob› is interpreted as the
        application | f x of ‹ca›, where cf, cx are interpreted as combinators
        f, x respectively

      * The application of an ob interpretable as a combinator is
        interpretation-preserving and exhibits the same polymorphic functional
        type as the represented combinator.

      * The application of an ob interpretable as a combinator determines a
        definite result in accordance with the combinator's definition.

          o Here, the determination is of ‹ob› equality, "=" with regard to
            the derivation and its result.

          o There is no counterpart of ‹ca› equivalence, "≈" in ‹ob›.  When
            "≈" is asserted with respect to obs, it is relative to the ‹ca›
            interpretations offered here.

          o The relational "f ≅ g" is used to signify that obs f and g,
            interpreted as operator scripts, are either identical or have the
            same effect when interpreted as functions in ‹ob› having the same
            functional type.

      * The computational interpretation in ‹ob› is imperative and eager.
        Applications are carried out once the operator and the operand are
        each computationally determined and not before.

    3.2 Representing K, I, and S

    Three simple combinators are derived completely to illustrate the
    methodology of combinator definition satisfaction (cf. 2.3).

    3.2.1 Representing K

          ^cK = obap.E
          ^cK ≈ K

    For | K x y ≈ x, obap.ap(obap.ap(obap.E, a), b) = a.
    Also,            obap.eval((obap.E :: ` a) :: ` b) = a
    for any obs a, b, including representations of combinators.
    In oFrugalese,   (.E x) y = x

    This is very direct because

         obap.ap(obap.E,x) = ob.e(x),
         obap.ap(ob.e(x),y) = x,
    and  obap.eval(obap.E) = obap.E,
    all by definition.

    Although it seems rather wasteful and even risky to evaluate y for no
    apparent purpose (since the attempted evaluation might fail to yield a
    result), it happens that there are valuable idioms where y is fixed
    (e.g., `z) and is so-encapsulated within a script as a payload for
    some idiomatic purpose.

    Important.  It is part of the strict semantics for oMiser that an
    application (^cK x) y cannot be simplified unless it is assured that
    evaluation of y has a definite computational result whenever evaluation
    of x does.

    3.2.2 Representing | I x ≈ x

            ^cI = ob.NIL
            ^cI ≈ I

    For | I x ≈ x,  obap.ap(ob.NIL, a) = a.
    Also,           obap.eval(ob.NIL :: ` a) = a
    In oFrugalese,  .NIL x = x

    This is also very direct because
         obap.ap(ob.NIL,x) = x,
    and  obap.eval(ob.NIL) = ob.NIL,
    also all by definition.

    3.2.3 Representing | S x y z ≈ x z | y z

           ^cS ≈ S

    where  ^cS = .C :: `.C
                    :: .C :: (.E :: .C :: (.E :: .ARG)
                                       :: `.ARG)
                          :: `(.C :: (.E :: .ARG)
                                  :: `ARG),
           obap.ap(^cS, x)
               = .C :: `( `x :: .ARG)
                    :: .C :: (.E :: .ARG) :: `.ARG),
           obap.ap(obap.ap(^cS, x), y)
               = (`x :: .ARG) :: `y :: .ARG),
           obap.ap(obap.ap(obap.ap(^cS, x), y), z)
               = obap.ap( obap.ap(x, z), obap.ap(y, z) ),
    and in oFrugalese, ^cS(x, y) z = x(z) y z.

    3.3 Derived Utility Combinators B, C, D, T, and W

    For the additional useful combinators (1.2), we provide the chosen-idiom
    representation as operator-script obs.  The derivations have been
    obtained and confirmed using the SML/NJ mockup at
    <https://github.com/orcmid/miser/blob/master/oMiser/mockups/SML/combdemo.sml>.
    These tend to be more compact than equivalent combinator representations
    obtained by application of cS, cK, and other combinator representations
    alone.  Automation of such streamlining and further optimizations will
    be the subject of further exploration.

    3.3.1 Representing | B f g x ≈ f | g x

           ^cB ≈ B

    where  ^cB = .C :: `.C
                    :: .C ::  ( .E :: .E :: .ARG )
                          :: `( .C :: ( .E :: .ARG ) :: `.ARG )

    3.3.2 Representing | C f x y = f | y x

          ^cC ≈ C

    where ^cC = .C :: `.C
                   :: .C :: ( .E :: .E :: .ARG )
                         :: `( .C :: `.ARG :: .E :: .ARG )

    3.3.3 Representing | D f x g y = f x | g y

          ^cD ≈ D

    where ^cD = obap.ap(^cB, ^cB)
              = .C :: ``^cB
                   :: .C :: (.E :: .ARG) :: `.ARG
              = .C :: ``( .C :: `.C
                             :: .C :: ( .E :: .E :: .ARG )
                                   :: `( .C :: ( .E :: .ARG ) :: `.ARG ) )
                   :: .C :: ( .E :: .ARG ) :: `.ARG

    3.3.4 Representing | T x f ≈ f x

           ^cT ≈ T

    where  ^cT = .C :: `.ARG :: .E :: .ARG

    3.3.5 Representing | W f x ≈ f x x

          ^cW ≈ W

    where ^cW = .C :: ( .C :: ( .E :: .ARG ) :: `.ARG )
                   :: `.ARG


 4. RECURSION AND EXOTIC COMBINATORS

    4.1 Conditional Behavior

    4.2 The Y Combinator Interpretation

    4.3 The Uβ Combinator and Truth Indifference

    The quasi-combinator Uβ is fixed on a definite type, β, having exactly
    two values, such that

           Uβ: β → (α -> (α → α) )

         | Uβ b x y is equivalent to either x or y depending on b,

         | Uβ b ≈ K, when b is the first case, so that | K x y ≈ y

                ≈ K I, when b is the second case, so that | K I x y ≈ y


    Requiring that operands x and y be of the same functional type, α, is
    consistent with the notion that they each be applicable in the same
    interpretation-preserving context.

    Requiring that β be a type of two distinguishable entities is baffling
    if we expect that β be a combinator.  We do not presume any means for
    such strict differentiation among combinators [CL2018: 5. Undecidability of Combinatorial Calculus].

    For oMiser, we have, under ‹ob›, any number of distinct obs from which
    we can select two as comprising a suitable type as β.  With respect to
    obap.ap, the natural choice is the two primitive individuals obap.A and obap.B, the specific results of the obap.d function.  We define type obAB.

        obap.A: obAB,
        obap.B: obAB

    and now UobAB can be determined.

        UobAB: obAB -> (α -> (α → α) )
        | UobAB obap.A ≈ K
        | UobAB obap.B ≈ K I

    with representation

        ^UobAB ≈ UobAB
               = .ARG :: `(^cK :: ^cK ^cI)
               = .ARG :: `(.E :: `.NIL)

    In usage of the ^UobAB operator script, it is required that the operand
    be restricted to type obAB (section 2.4).  The definition of ^UobAB
    is here based on the assumption (a pre-condition) that the operand will be
    derived in a manner that any yield is of type obAB, affording this
    streamlined computation.

    It is commonplace to associate the notions of truth and falsity with
    specific entities.  For example, in use of combinators, one practice is
    to associate K and | K I with true and false, respectively.  The same
    temptation arises for obap.A and obap.B as representations of true and
    false.  Even though definition of UobAB preserves such a correspondence,
    the intention to correspond to particular truth values is not inherent,
    and such an association can vary from one case to another.  Specific truth-value interpretation is not inherent in the definitions as given.

    In practice, the interpretation of certain functions that yield values of
    type obAB is as if obap.A corresponds to the satisfaction (truth) of some
    condition and obap.B corresponds to the condition not being satisfied (and
    false).  This commonplace is a matter of interpretation and it is not
    inherent to the obap.A and obap.B themselves.

    The connection with obap.ap function D(ob1,ob2) is suggestive of an useful idiomatic interpretation.  But note that D(ob1,ob2) of obap.ap determines equally whether ob1 and ob2 are the same or whehter they are different and that intension determines which of obAB is "truth" in the respective case of usage.  That is not to say there is no value in a
    fixed convention, only to affirm that it is by convention.

    Akin to our observation of the interpretation-preserving nature of
    combinator functional types, we state that Uβ and type β are truth
    indifferent while also truth-value interpretation-preserving.  It all
    depends on how the choice of x versus choice of y is interpreted.
    For more on the trickiness of computational notions of truth, see
    <https://github.com/orcmid/miser/blob/master/truth.txt>.

    Treatment of Uβ is inspired by the function | ⊃ b x y of [Scott1993],
    also written (b → x, y), where the type of b is of two distinct values,
    signified ⊤ and ⊥ (typically interpreted as T and F or true and false).
    Scott's inclusion of an undefined entity, Ω, is not a notion of ‹ca›
    nor of ‹ob›.  For oMiser, an expression (evaluation) can be said to be
    undefined in speaking about an evaluation, but not about any result an evaluation yields within the computational model.  In oMiser, such cases
    yield no result whatsoever as does any application depending on their
    being a determined value.

    There is a similar treatment to | ⊃ b x y for the form | D x y b in  [Feferman1977: 2.1.2], where | D x y 0 = x and |D x y 1 = y, without
    explicit association with truth values.  There is some association with Boolean algebras and also with sets being empty (by 1) or not (by 0).


 5. REFERENCES AND RESOURCES

   [Barendregt1981]
      Barendregt, Hendrik Pieter.  The Lambda Calculus: Its Syntax and
      Semantics.  North-Holland (Amsterdam: 1981).  ISBN 0-444-85490-8.

   [Burge1975]
      Burge, William H.  Recursive Programming Techniques.  Addison-Wesley
      (Reading, MA: 1975).  ISBN 0-201-14450-6.  Although the approach starts
      with a functional-style, the interconnections and definability in terms
      of combinators and closed λ-expressions is worked up to in Chapter 1,
      with further refinement (and implementation matters) thereafter.

   [CL2018]
      Combinatory Logic, Wikipedia Article, accessed on the Internet on
      2018-05-15 at <https://en.wikipedia.org/w/index.php?title=Combinatory_logic&oldid=840550936>.

   [Feferman1977]
      Feferman, Solomon.  Theories of Finite Type Related to Mathematical
      Practice.  Chapter D.4 in "Handbook of Mathematical Logic," Jon Barwise
      (ed.), North Holland (Amsterdam: 1977), ISBN 0-444-86388-5 pbk.

   [Paulson1996]
      Pauson, Lawrence C.  ML for the Working Programmer, ed.2.  Cambridge
      University Press (Cambridge: 1991, 1996).  ISBN 0-521-56543-X pbk.
      Digging into the combinators, λ-calculus, and representation of other
      types as interpretations of λ-expressions occurs in Chapter 9, Writing
      Interpreters for the λ-Calculus, starting in section 9.5.

   [Révész1988]
      Révész, György E.  Lambda-Calculus, Combinators and Functional
      Programming.  Cambridge University Press (Cambridge: 1988), ISBN
      0-521-345589-8.  The notational use of (f)(x)y for conventional f(x(y)),
      applicative f(x y), and combinatory | f | x y requires careful reading.
      Chapter 3, Combinators and Constant Symbols, provides extensive examples
       also relevant to computational representations.  Section 2.4 provides
      a treatment of λ-expressions that can be adapted to the closed use
      in (1.2) here.

   [Rosenbloom1950]
      Rosenbloom, Paul C.  The Elements of Mathematical Logic.  Dover (New
      York: 1950).  ISBN 0-486-60227-3 pbk.  The notation for expressing
      combinators (1.1 here) and the expression of‹ca› are derived from
      section III.4, Combinatory Logics.

   [Scott1977]
      Scott, Dana S.  Logic and Programming Languages. 1976 ACM Turing Award
      Lecture.  Comm. ACM 20, 9 (September 1977), 634-641.  PDF availabe at
      <http://delivery.acm.org/10.1145/1290000/1283932/a1976-scott.pdf>.  The
      discussion on semantic structures and function space is a valuable
      collateral on the use of monotonicity and continuity in [Scott1993],
      a paper originally circulated informally in 1969.

   [Scott1993]
      Scott, Dana S.  A Type-Theoretic Alternative to ISWIM, CUCH, OWHY.
      Theoretical Computer Science 121, 1-2 (December 1993), 411-440. At
      <https://www.sciencedirect.com/science/article/pii/030439759390095B>.
      The type-theoretic approach treats type as definite and distinguished
      even though the combinators are interpretable as polymorphic in the
      manner proposed here for combinator representation in oMiser.

   [Scott2012]
      Scott, Dana S. λ-Calculus Then & Now.  Annotated slides presented at
      conferences, PDF version of 2012-08-25 available on the Internet at
      <http://logic.berkeley.edu/colloquium/ScottACMTuring.pdf>.  Presented
      at the ACM Turing Centenary Celebration, San Francisco, June 15-16,
      2012.  Video presentation at <https://doi.org/10.1145/2322176.2322185>.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

                   Copyright 2018 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 TODO:

  * Link to other materials of the Miser Project that explore some of these
    matters in greater detail.  Connect to combdemo.sml, and also work in
    Ycombinator (.txt or .sml?), and comblib.sml.

  * Salvage this statement somewhere here? "Combinator representations applied
    to representations of other types of functions will lead to some valuable
    idioms in the composition of oMiser applicative scripts from other,
    simpler ones."

  * Find an accessible, specific reference for the functional-type notation.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 0.0.10 2018-05-20-13:25 Complete the draft of 4.3, introducing Uβ and Truth
       Indifference.   Related touch-ups.
 0.0.9 2018-05-18-17:40 Touch-ups, have functional-type derivation of K be
       on the same pattern as the others (arguments taken right to left).
       Expand section 4 and add draft of 4.1.3 for the U combinator.
 0.0.8 2018-03-08-15:37 Complete the first full draft of section 3 on the
       representation of the basic utility combinators.
 0.0.7 2018-03-07-14:16 Complete full draft of section 2 on Functional Type
       and Interpretation Preservation
 0.0.6 2018-03-02-19:14 Continue refinement and working through to section 2.4
 0.0.5 2018-02-26-10:39 Continue polishing and lead up to 2.4 on restricted
       interpretation.
 0.0.4 2018-02-21-14:48 Introduce 2.1 on Functional Type; manage TODOs
 0.0.3 2018-02-17-10:56 Polish and set the stage for the Y combinator.
 0.0.2 2018-02-13-10:00 Get past the Combinator Theory enough to talk about
       interpretation preservation.  Introduce λ-expressions.
 0.0.1 2018-02-11-21:10 Add section 1.1-1.2 In continuing development of
       the mathematical structure of combinators.
 0.0.0 2018-02-10-13:28 Placeholder and boiler plate for a description of the
       nature of combinators, the chosen representations, and the power of
       interpretation-preserving operation.

                   *** end of combinators.txt ***

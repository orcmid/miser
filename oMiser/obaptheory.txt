obaptheory.txt 0.0.12                 UTF-8                       dh:2017-09-28

                          MISER THEORETICAL CONCEPTION
                          ============================
                            
       <https://github.com/orcmid/miser/blob/master/oMiser/obaptheory.txt>

                       ‹ob› UNIVERSAL APPLICATIVE FUNCTIONS
                       -----------------------------------
                        
   For the mathematical structure, ‹ob› = <Ob,Of,Ot>, we demonstrate existence
   of a universal function, obap.ap(p,x) and an important companion obap.ev 
   employed in its construction and separate use via obap.eval(exp).   .  
   
   Universality of obap.ap(p,x) is taken to mean that for every function,
   F on obs that is effectively-calculable, there is an ob p that expresses
   an effective procedure such that obap.ap(p,x) = F(x) is determined.
     
   The grand objective is to establish that not only is obap.ap(p,x) 
   a universal function in this respect, but that it provides a model of
   commputation as powerful as any other, in harmon with the Church-Turing
   thesis.  
   
   Confirmation of these claims is developed separately.  Here we represent
   obap.ap(p,x) and obap.eval(exp) via Ot.
   
PRELIMINARIES

   The notation, mathematical theory, and primitive notions at obtheory.txt
   are incorporated directly.  See
   <https://github.com/orcmid/miser/blob/master/oMiser/obtheory.txt>
   
   For simplicity, the infix pair operator, ::, is introduced, with
   
          x :: y = ob.c(x,y)
          t :: u :: ... y :: z = t :: (u :: ... (y :: z) ...)
          
   Obap1. New Individuals
          
          Nine named individuals are employed including ob.NIL:
   
          obap.is-primitive(x) ⇒ ob.is-individual(x)
   
          obap.is-primitive(ob.NIL)
          
          obap.is-primitive(obap.A)
          obap.is-primitive(obap.B)
          obap.is-primitive(obap.C)
          obap.is-primitive(obap.D)
          obap.is-primitive(obap.E)
          
          obap.is-primitive(obap.SELF)
          obap.is-primitive(obap.ARG)
          
          obap.is-primitive(obap.EV)

          
ADDITIONAL NOTIONS

   Obap2. Literal Individuals
          
          obap.is-lindy(x) ⇔ x = Ʃs
             where s is a character string consisting of a letter optionally
                     followed by one or more alphanumeric characters
                     
          Ʃs = Ʃt ⇔ s = t
             where s = t signifies identity of the string texts
                        
          obap.is-lindy(x) ⇒ ob.is-individual(x)          
          obap.is-lindy(x) ∧ ¬ obap.is-lindy(y) ⇒ x ≠ y
                   
          Here a precarious example of introducing text into the
          theory language expression of arbitrary namings for distinct
          individuals in the subject domain.  Lindies are employed freely. 
          
          NOTE: Ʃs is not a function in ‹ob›.  Ʃs is a metalinguistic 
          notation for designating further, conveniently-named individuals
          in the universe of discourse, here written in forms such as
          Ʃalpha, ƩABCs, ƩletterQ, and Ʃfoo but having no significance
          in the theory and a minimal applicative interpretation (below).
          
  Obap3.  Universal Apply Function
  
             obap.ap(p,x) determines the application of ob p, taken as
                          expression of a procedure, to ob x, taken as
                          the argument
                      
           obap.eval(exp) determines the evaluation of ob exp taken as an
                          applicative expression          
          
          All other predicates and functions introduced in Obap4-Obap7 below
          support the representation of obap.ap and obap.eval 
          and need not be relied upon otherwise.
          
THE APPLY FUNCTIONS

   Obap4. obap.ap(p,x)
   
          obap.is-lindy(x) => obap.is-lindy-every-free(x)
          obap.is-every-free-lindy(c(x,y))
             ⇔ obap.is-every-free-lindy(x) ∧ obap.is-every-free-lindy(y)
             
          obap.is-lindy(x) => obap.is-lindy-everywhere(x)
          obap.is-lindy-everywhere(e(x)) ⇔ obap.is-lindy-everywhere(x)
          obap.is-lindy-everywhere(c(x,y))
             ⇔ obap.is-lindy-everywhere(x) ∧ obap.is-lindy-everywhere(y)
   
        ob.is-enclosure(p) ⇒ obap.ap(p,x) = ob.a(p)
        
        ob.is-individual(p) ⇒ obap.ap(p,x) = obap.apint(p,x)
        
        obap.is-every-free-lindy(p) ∧ obap.is-lindy-everywhere(x)
                => ob.is-pair(p) ⇒ obap.ap(p,x) = p :: x
        ¬ ( obap.is-every-free-lindy(p) ∧ obap.is-lindy-everywhere(x) )
                => ob.is-pair(p) ⇒ obap.ap(p,x) = obap.ev(p,x,p)
                              
   Obap5. obap.apint(p,x) applicative treatment of individuals.
   
        obap.apint(ob.NIL, x) = x
        obap.apint(obap.A, x) = ob.a(x)
        obap.apint(obap.B, x) = ob.b(x)
        obap.apint(obap.C, x) = obap.C :: ob.e(x) :: obap.ARG
        obap.apint(obap.D, x) = obap.D :: ob.e(x) :: obap.ARG
        obap.apint(obap.E, x) = ob.e(x)
               
        obap.is-lindy(p) ∧ obap.is-lindy-everywhere(x)  
                         => obap.apint(p,x) = p :: x
        obap.is-lindy(p) ∧ ¬ obap.is-lindy-everywhere(x)  
                         => obap.apint(p,x) = p :: ob.e(x)
                       
        obap.apint(obap.SELF, x) = ob.e(obap.SELF) :: ob.e(x)
        obap.apint(obap.ARG, x) = ob.e(obap.ARG) :: ob.e(x)
        obap.apint(obap.EV, x) = obap.eval(x)
        
        A trace is a form, t, such that obap.ap(t,obap.NIL) = obap.eval(t) = t.
        This supports a form of symbolic evaluation in the case of individuals,
        such as lindies, that lack an applicative interpretation. 
        
        The obap.apint evaluations for obap.C and obap.D determine partial
        applications, effectively currying use of functions ob.c and obap.d.
             
       
 THE EVALUATION FUNCTIONS
 
   Obap6. obap.ev(p,x,e) evaluation of script e as part of determining the
          application of procedure p to argument x
   
        obap.is-evref(obap.SELF)
        obap.is-evref(obap.ARG)
        
        obap.ev(p,x,obap.SELF) = p
        obap.ev(p,x,obap.ARG) = x
        
        ob.is-individual(e) ∧ ¬ obap.is-evref(e) ⇒ obap.ev(p,x,e) = e
        
        obap.ev(p,x,ob.e(y)) = y
        
        obap.is-evbinop(obap.C)
        obap.is-evbinop(obap.D)
        
        obap.ev(p,x,obap.C::e1::e2)
           = ob.c(obap.ev(p,x,e1), obap.ev(p,x,e2))
           
        obap.ev(p,x,obap.D::e1::e2)
           = obap.d(obap.ev(p,x,e1), obap.ev(p,x,e2))       
        x = y ⇒ obap.d(x,y) = obap.A
        x ≠ y ⇒ obap.d(x,y) = obap.B
           
        obap.is-evbinop(e1) ∧ ob.is-singleton(e2)
           ⇒ obap.ev(p,x,e1::e2) = obap.ap(e1, obap.ev(p,x,e2))
           
        obap.is-evunop(obap.EV)
        obap.ev(p,x,obap.EV :: e2) = obap.ev(p,x,obap.ev(p,x,e2))
           
        ¬ ( obap.is-evbinop(e1) ∨ obap.is-evunop(e1) ) 
           ⇒ obap.ev(p,x,e1::e2) = obap.ap(obap.ev(p,x,e1), obap.ev(p,x,e2))
        
   Obap7. obap.eval(e)
   
        obap.eval(e) = obap.ev(obap.SELF, obap.ARG, e)
        
     
   
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

                       Copyright 2017 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
TODO
  
 * Reflect the trace business in the definition of ap and elsewhere earlier,
   perhaps so it is easier to understand the business of tracing. Maybe this
   goes in Obap3.

 * Provide a stable location for obaptheory version progressions on 
   <http://miser-theory.info>.
   
 * Add a section on the effective computability of Of and the necessary partial
   nature of obap.ap and obap.eval.
      
 * It remains open whether obap.ap should be exposed, although it appears to
   be quite handy and at the root of the applicative approach.
   
 * Determining how types are handled and generally individuals representing
   extended functions remains open.
   
 * Introduced obap.PROC to demonstrate some of the power of immutability and the
   ability for processors to optimize operation.  It also affirms the idea
   of preserving extensional identity, something to be developed further.
   
 * Introducing obap.DEF is required in order for the universal function to
   be simulated by some script, p.  This reflection-like feature has me be
   nervous.  The system must be able to look within.  I am resisting having 
   scripts able to accomplish that.  
   
 * It is mildly interesting that representation in a mathematical theory
   has no concern about tail recursion or other optimizations.  It doesn't
   even have the requirement on computation that a definite ob be arrived
   at consisting entirely of individuals combined with ob.e and ob.c.
   
 * How we establish what a computational manifestation accomplishes 
   and how one can assert the soundness of various optimizations is not
   found here.  This provides a possibly-interesting further contrast 
   between the representation of obap.ap and obap.eval in a mathematical theory
   in contrast with the reasoning that may be required to affirm the soundness
   of a computational manifestation.  
   
 * A trace is a kind of self-recreating K-combinator application, so its
   applications will always terminate.  As a result, it can derail an ob.d
   in a manner that has a procedure fail to terminate.  Need to document 
   that when it comes to testing at the oMiser level.
   
 * I could have called trace "trap" instead, since it traps the computation.
   In that case, it is different than "trap" as originally introduced for
   hardware interrupts and throwing of (catch-able) exceptions.
   
 * There is too much in here about intended computational manifestations,
   and need to focus more on the theory, even though something about
   intentions is useful.
   
 * Inside Joke: It was tempting to call lindies Milners because of the way
   the SML specification uses composed words to signify grammar rules.  I'm
   saving that for later, when the Ershov-Duncan-Milner scheme for extending
   context-free grammars comes under scrutiny.
   
 * The "::" use is from SML.  It is difficult not to use it once it has been
   seen and applied in practice.  There is no list type at this point, however.
   
 * The use of obap.SELF in obap.ev has the effect that every procedure has a
   kind of Y-combinator built-in.  It depends entirely on the script, p, whether
   and how the prospective recursion is employed.  
   
 * The inspiration behind obap.SELF and obap.ARG extends back to my reading the
   1965 publication of Strachey's macrogenerator (GPM or McG) paper in The
   Computer Journal, <https://doi.org/10.1093/comjnl/8.3.225>.  The ob.e 
   function is inspired by a defect/limitation/incompleteness in McG, although
   here applied to "list" structures instead of strings having nested strings
   as beads.  Switching to the more flexible pair structures was inspired
   by the XLISP (1.0?) paper in Dr. Dobb's Journal in the early 80s.  The coin
   hadn't dropped until then, although I had already had seen McCarthy's 
   "Part 1" in 1961, thanks to joining the ACM and also finding Comm.ACM back
   issues in the stacks of the Seattle Public Library (not an ordinary public
   library of the time before emergence of computer science as a discipline).
   
 * Historical Note: McG was used by the ISWIM team at Univac (using a Univac
   1107, and didn't we call it YSWIM?) and, I'm told, the Backus FP team in San
   Jose as a means of boot-strapping their respective machine-language 
   implementations.  There was no C Language yet and work on creating the then-
   called system-programming language PLUS/0 was post-YSWIM.  I don't know if
   IBM's BSL (PL/S) was a candidate for the Backus FP team.
   
 * Historical Note: The intimate connection of ap and ev is characteristic 
   of the formal computation machinery of John McCarthy's LISP.  It's too 
   powerful to avoid.  In other respects, there are an accumulation of 
   differences here.  There is no dynamic binding/scoping, there are no
   symbolic references, obs are immutable, the primitives are total, predicates
   on the primitive notions are definable on characteristics of the structure
   alone, and there are no variables (and no FunArg problem): obap.ap and
   obap.eval all determine results by rewriting and application alone.  There's 
   also a serious absence of useful data types, and that remains to be
   addressed.
   
 * The special treatment for is-lindy-every-free(p) and is-lindy-everywhere(x)
   is designed to simplify the production of traces having lindies standing as
   points of abstraction for substitution of "variable" enclosed obs.  This
   needs to be analyzed more carefully.  It is very costly yet applicative 
   interpretation of lindies needs to be definite.
   
 * Construct sufficient tests of lindy treatment in an implementation to 
   demonstrate that the current applicative interpretation is adequate and 
   has no nasty edge cases.
   
 * Find my correspondence with John McCarthy about my early ideas on Miser and
   his recommendation.
  
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 0.0.12 2017-09-28-15:37 Add obap.EV, its applicative interpretation and its
       special form in obap.ev.
 0.0.11 2017-09-28-14:48 Adjust TODOs. Remove ob.PROC and ob.DEF for treat-
       ment of extension mechanisms.  Simplify the introduction of notions
       about universality based on discussion with Paul McJones.  Recover the
       change from is-lindy-every-free to is-every-free-lindy that got lsot
       somewhere.
 0.0.10 2017-09-25-19:59 Restate Obap8 to have the definitons of obap.proc(p),
       obab.def(x), and the applicative interpretations of obap.PROC and 
       obap.DEF to parallel the approach for other parts of obaptheory.
 0.0.9 2017-09-25-16:57 Adjust TODOs, introduce ob.PROC and ob.DEF
 0.0.8 2017-09-20-10:09 Reflect the application of lindies in a manner that
       supports symbolic traces of evaluations, based on the lack of any
       distinct interpretations lindies as anything else.
 0.0.7 2017-09-19-19:45 Add is-lindy-every-free(x) and is-lindy-everywhere(x).
       Recast the statement of universal computation in terms of effective-
       universality of the functions obap.ap(p,x) and obap.eval(exp).
 0.0.6 2017-09-16-10:22 More TODOs and some touch-ups.  Consistently use obap.*
       for notions expressed in obaptheory beyond the primitive ob.* ones that
       remain applicable to all of Ob.
 0.0.5 2017-09-12-15:05 Remove Treatment of individuals not in evidence.
       There is no reason for this in obaptheory.  Simplify lindies to be
       just symbols that represent themselves and have no theoretical
       significance beyond applicative evaluation as traces.
 0.0.4 2017-09-12-12:56 Restore obap.SELF and obap.ARG to primitives and
       correct their tracing cases.  Rework explanatory material.  Add TODOs
       including historical notes for now.
 0.0.3 2017-09-11-19:55 Remembered to add definition for ob.d(x,y)
 0.0.2 2017-09-11-19:20 Proof-reading corrections, text touch-ups
 0.0.1 2017-09-11-19.04 Create the initial draft.



                          *** end of obaptheory.txt ***                               
   
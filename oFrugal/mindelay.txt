mindelay.txt 0.0.2                  UTF-8                          2022-08-06
----|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                           The Miser Project Code
                           ======================

      <https://github.com/orcmid/miser/blob/master/oFrugal/mindelay.txt>

                   OFRUGAL REPL MINDELAY PARSER DESIGN
                   -----------------------------------

MINDELAYSCANDOER

    A mindelayscandoer refers to programming-language compiling techniques
    in which the the scanning of the text leads provides translation to final
    computer code as quickly as possible [Evans1961:n.2].  This tends to be
    associated with translation that occurs in a single pass over the text.

    In the case of the oFrugal REPL (Read-Evaluate-Print Loop) there is no
    production of code.  The oFrugal REPL is more like a calculator, in that
    it accepts expressions in the oFrugal REPL language and delivers a
    canonical expression for the calculated ob.

    In the proof-of-concept oFrugal REPL, evaluations happen as soon as the
    operands of an operation are available in the parsing of the input being
    read. The idea is to minimize drag, the amount of intermediate results
    that must be held onto until their consuming operations are determined.
    In this manner, the parsing of the input and performance of operations
    occur as the scanning progresses.

    Although the oFrugal REPL operates about as quickly as conceivable, there
    are difficulties with regard to errors in the input and troubles in the
    evaluations.  Any of these can cause the scanning to cease.  The remedy
    is by not performing any evaluations until a complete REPL expression has
    been scanned, delaying the required operations until the expression is
    scanned completely and successfully. In effect, the operations are kept
    in a compiled form that is then "executed" after a successful parse.

    The proof-of-concept oFrugal REPL implementation will not delay any
    evaluations.  Once the operands of an operation are in-hand, the operation
    will be performed.  Fortunately, the same parsing technique is applicable,
    later, by having operations produce an intermediate for their delayed
    evaluation when the input is parsed completely and successfully.

GRAMMATICAL ACCURACY

    The early operator-precedence techniques tended to be under-specified.
    In particular, some grammatically-incorrect strings were accepted and
    would produce results even though the input is malformed [Samelson1969].

    This stemmed partly from the development of operands and intermediates
    on a different stack than one holding the as-yet-uncompleted syntactic
    components. It becomes possible for the two stacks to become out of
    sync, either accepting an ungrammatical input or having an operation fail.
    This can be a reflection of there being no formal grammar that the input
    is held to.

    For the oFrugal REPL, every input must be grammatical, and every accepted
    input will have an applicative interpretation.

ERROR HANDLING







 - talk about the difficulties of error handling

 - Set up the precedence rules for the variant cases.

 - Identify the format for error messages

 - Identify the idea about association of interpretations to the patterns


NOTES AND REFERENCES

    [Backus1959]
        Backus, John W. The syntax and semantics of the proposed international
        algebraic language of the Zurich ACM-GAMM Conference.  Proceedings of
        the International Conference on Information Processing, UNESCO
        (Paris: 1959), 125-132. Available on the Internet at
        <https://www.softwarepreservation.org/projects/ALGOL/paper/Backus-Syntax_and_Semantics_of_Proposed_IAL.pdf/view>

    [Cheatham1964]
        Cheatham, T.E.Jr., Sattley, Kirk.  Syntax-Directed Compiling.
        Proceedings of the April 21-23 1964 Spring Joint Computer Conference
        (AFIPS: April 1964), 31-57.  A general parser (syntax analyzer) for
        context-free languages is described.  What we now refer to as a
        lexical analyser is identified as a recognizer layer.  The analyzer
        method is most easily recognized as a top-down parser with back-
        tracking.  It could even be used to produce all analyses available for
        an ambiguous input.  Refinements of this method that I have explored
        include pruning alternatives when they cannot be possible if the
        input will be valid.  This allows early analysis to be forwarded to
        a generation layer.  There also needs to be some assistance in the
        case of left-recursive generations, usually expedited by transforma-
        tion into tail-iterative forms.

    [Chomsky1956]
        Chomsky, Noam.  Three models for the description of languages.  IRE
        Transactions on Information Theory 2, 3, 113-124.
        <https://doi.org/10.1109/TIT.1956.1056813>.  Available on the Internet
        at <https://chomsky.info/wp-content/uploads/195609-.pdf>.
           Seeking a model applicable to natural languages, Chomsky identifies
        finite-state languages (now type 3: regular expressions), phrase-
        structure languages (now type 2: context free), and transformational
        languages, the last having his focus.

    [Chomsky1959]
        Chomsky, Noam.  On certain formal properties of grammars.  Information
        and Control 2, 2 (1959), 137-167.
        <https://doi.org/10.1016/S0019-9958(59)90362-6>.
           Here Chomsky's models are formalized more fully, establishing a
        hierarchy from recursively-enumerable (type 0, uninteresting for
        linguistics) and descending into strictly-tighter subsets with
        context-sensitive (type 1), context-free type 2), and finite state
        (type 3).  There is a layer (recursive languages) within type 0 and
        containing type 1, so all of types 1-3 are recursive and hence
        decidable.  These are generative grammars: production of grammatical
        strings is described, not to be confused with notation-borrowing
        schemes for the parsing of such text strings.

    [Evans1961]
        Evans, A., Perlis, A.J., Van Zoeren, H. The Use of Threaded Lists in
        Construction of a Combined ALGOL and Machine-Like Assembly Processor.
        Comm. ACM 4, 1 (Jan. 1961), 36-41.
        DOR <https://dl.acm.org/doi/10.1145/366062.366081>.
           Footnote 2 on p.37 describes "mindelayscandoer" as "scan and do
        translation to final code as quickly as possible."  The idea of
        threaded lists does not apply well to oMiser, though a counterpart
        might assist in operator-precedence handling.

    [Floyd1963]
        Floyd, Robert W.  Syntactic Analysis and Operator Precedence.  J. ACM
        10, 3 (July 1963), 316-333.
           Floyd provides a mechanical means of producing precedence parsers
        when grammars are specified in a form for which definite precedence
        conditions can be derived.  The special case of assigning numerical
        precedence values to syntactic features and then comparing those,
        among other enhancements, are found by formal means.  The full
        analysis technique is particularly valuable in testing that a grammar
        admits operator-precedence parsing simplicity and automatic production
        is valuable when modifications of the language are anticipated.

    [Gorn1963]
        Gorn, Saul.  Detection of Generative Ambiguities in Context-Free
        Mechanical Languages.  J. ACM 10, 2 (April 1963), 196-208.
        <https://doi.org/10.1145/321160.321168>.
           Section 1, Introduction, offers a precise definition of context-
        free (mechanical) languages along with important considerations such
        as their decidability.  Although it is undecidable, in general,
        whether a given context-free grammar is ambiguous, it is possible to
        determine when a particular statement is by relying on a parser such
        as that of [Cheatham1964].

    [Knuth1962]
        Knuth, Donald E.  A History of Writing Compilers.  Computers and
        Automation 11, 12 (December 1962), 8-18.  Reprinted in Chapter 20,
        pp. 439-456 in Donald E. Knuth, Selected Papers on Computer Languages.
        CSLI Publications (Stanford, CA: 2003).  ISBN 1-57586-382-0 pbk.
           The explanation of operator precedence and its illustration is very
        close to how the oFrugal REPL parser will parse and interpret ob-exp
        formulas.

    [Naur1963]
        Naur, Peter (ed.)., Backus, J.W., Bauer, F.L., Green, J., Katz, C.,
        McCarthy, J., Perlis, A.J., Rutishauser, H., Samelson, K., Vauquois,
        B., Wegstein, J.H., Van Winjgaarden, A., Woodger, M.  Revised Report
        on the Algorithmic Language ALGOL 60.  Comm. ACM 6, 1 (January 1963),
        1-17. DOI <https://doi.org/10.1145/366193.366201>.
           Although the 1960 publication is often cited, corrections were
        called for, leading the the 1963 Revised Report.  Some ambiguities
        in the grammar were repaired.

    [Pratt1973]
        Pratt, Vaughan R.  Top Down Operator Precedence.  Proc. 1st Annual ACM
        SIGACT-SIGPLAN Symposium on Priniciples of Programming Languages
        (October 1973), 41-45.  <https://doi.org/10.1145/512927.512931>.
           This technique has found considerable favor at varous points in
        time.  Section 1, Survey of the Problem Domain, and early parts
        of section 2, Three Syntactic Issues, are valuable for considerations
        of the desire for operator precedence simplicity. The technique
        depends on the creation of procedures that apply to various elements
        in the course of parsing that is not quite how interpretation is
        specified for the oFrugal grammar.  The considerations do apply.

    [Samelson1960]
        Samelson, K., Bauer, F.L.  Sequential Formula Translation.
        Comm. ACM 2, 2 (Feb. 1960), 76-83.
        DOR <https://dl.acm.org/doi/10.1145/366959.366968>.
           This paper describes a cellar (ie., stack) principle for
        translation of algorithmic expressions, treating precedence of infix
        operators. The stack of (intermediate) operands is kept separate.

----|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

                    Copyright 2020-2022 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

----|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 ATTRIBUTION

   Hamilton, Dennis E. oFrugal REPL Mindelay Parser Design.  Miser Project
   Code tex file oFrugal.txt version 0.0.2 dated 2022-08-06 available on the
   Internet as a version of
   <https://github.com/orcmid/miser/blob/master/oFrugal/oFrugal.txt>

TODO

  * mindelay.txt is the REPL parser structure.  It is related to the Alan
    Perlis "mindelay-scan-doer" scheme for a mostly one-pass process where
    an operation can be carried out as soon as its operands are determined.
    For oFrugal that one-pass process calculates obs and provides for the
    binding of obs and the access to those bound obs in subsequent
    expressions.  This is a moderately-extended precedence parser.  Behavior
    of this parser procedure can be verified against the context-free grammar
    for the same oFrugal texts.  The handling of error cases is beyond what
    the grammar determines.

  * "mindelayscandoer" is described as "scan and do translation to final code
    as quickly as possible" in footnote 2 on p.37 of A. Evans Jr., A. J.
    Perlis, and H. Van Zoeren.  The Use of Threaded Lists in Construction of a
    Combined ALGOL and Machine-Like Assembly Processor.  Comm. ACM 4, 1 (Jan.
    1961), 36-41.  DOR <https://dl.acm.org/doi/10.1145/366062.366081>.  I feel
    that I had seen an earlier use of the term in something earlier.  For
    oFrugal mindelay is even shorter, since the REPL is essentially a
    calculator and it derives interpretations as quickly as all dependencies
    are in hand.  mindelay.txt will account for the downside of that approach.

  * Also reference Knuth and the cellar principle folk, along with the paper
    on Precedence languages by Bob Floyd.  The use of a precedence-based
    parser is also aligned with the mindelay concept, since it basically
    turns the input into a reverse polish form where every operation can be
    performed when an operator is added to the stream.


----|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*

 0.0.2 2022-08-06T17:39Z Intermediate draft back-up
 0.0.1 2022-08-02T00:16Z Customize the boilerplate
 0.0.0 2022-08-01T01:56Z Clone oFrugal.txt as placeholder and boilerplate.

                        *** end of mindelay.txt ***

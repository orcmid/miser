grammars.txt 0.0.1                  UTF-8                         2022-08-12
----|----1----|----2----|----3----|----4----|----5----|----6----|----7----|--*


                           The Miser Project Code
                           ======================

    <https://github.com/orcmid/miser/blob/master/oFrugal/grammars.txt>

            FORMAL GRAMMARS AND INTERPRETATIONS FOR oMISER
            ----------------------------------------------

    Ob-exp texts are used as a means of specifying obs and computations
    with them to derive an ob result.  Ob-exp is an expression language
    that is used in digital communication of computations with obs and
    also used to submit expressions for oMiser computation via oFrugal.

    ob-exp has a context-free grammar, here specified using the original
    Backus-Naur Form (BNF) as employed in the Revised Report on
    the Algorithmic Language ALGOL 60.  The grammar specifies exactly those
    expressions that can be evaluated to (at most) a single ob when submitted
    to a processor such as an oFrugal implememtation.

    In addition to the grammatical structure for composing ob-exp
    expressions, there is also a formal definition of the computation by
    which an ob-exp is evaluated as computation of a canonical ob, the
    formal semantics of ob-exps.  It is this fact that has ob-exp be defined
    under oMiser, even though it is oFrugal that will enact that semantics.

    For an informal introduction to the use of Frugalese in the computational
    model defined on the mathematical structure ‹ob› = 〈Ob,Of,Ot〉, see
    <https://github.com/orcmid/miser/blob/master/oMiser/ob.txt> and other
    material cited there.




    The following summary form of the grammar is useful for reference.
    It does not address the grammatical differences that are called for
    to align with the interpretation rules by which an ob-exp is evaluated.
    The notation is the same used for the ALGOL 60 Report [Naur1963], as
    adapted from a John Backus demonstration for ALGOL 58 [Backus1958].

        The concrete reference syntax consists of Unicode, usually in UTF8
    encoding, and a %-escape mechanism is used when a character is not
    printable.  It is recommended that characters that are not easily typed
    be avoided by authors of ob expressions, recognizing that a recipient
    may encounter %-encoding instead.  If you don't know what this is about,
    you are probably on safe ground.

    Basically, white-space is allowed wherever it does not change the
    grammar of a 〈term〉 and required where consecutive 〈term〉 occurrences
    would not be disambiguated.


 2. EXPRESSION INTERPRETATION

    Interpretation of expressions as obs is accomplished using a special
    schema notation that specifies the Ot (‹ob› theory-language) expression
    interpretation of a given ob-exp text.  The interpretation schemas have
    distinct form.

       ‼ category ⎾pattern⏋{parameter-list} =: interpretation

    where      category is one of the syntactic categories, such as
                        〈ob-exp〉, 〈ae〉, and 〈term〉

                pattern is one of the patterns for the particular category,
                        such as 〈binary〉, 〈obap-form〉 〈ae-form〉, and 〈lindy〉

       {parameter-list} is an optional form consisting of a list of
                        one-or-more parameters

         interpretation is an obaptheory expression schema in which any
                        parameter and "‼ category {parameter-list}" forms are
                        in reference to category appearances in the pattern;
                        parameters of the pattern {parameter-list} may
                        occur as variables in the interpretation, including
                        in further {parameter-list} forms.

    The obaptheory formulation in Ot, the theory language of structure
    ‹ob› = 〈Ob,Of,Ot〉, is available at
    <https://github.com/orcmid/miser/blob/master/oMiser/obaptheory.txt>.

    For example,

        ‼〈ae〉⎾〈obap-form〉 〈ae-form〉⏋{ℰ} =: obap.ap(‼〈obap-form〉{ℰ},‼〈ae-form〉{ℰ})

    On the right-hand side of the "=:" the category names refer to those
    in the pattern on the left-hand side, and the interpretations of those
    occurrences is called for to determine the individual ob that is their
    evaluation.

    The parameter ℰ employed in many interpretations signifies the ob-exp
    environment, the means by which the current oFrugal set of bindings
    is used to resolve binding names and provide unknown-name forms otherwise.
    This is tied to interpretation of oFrugal statement-level syntax.

    Although the rules are tied directly to the forms of the grammar, the
    notation is relaxed to also describe interpretation of parsing stages.
    For example (cf. section 9),

      ‼〈ob-exp〉⎾ f g x ⏋{ℰ}
          =: ‼〈binary〉⎾ f g x ⏋{ℰ}
          =: ‼〈ae-form〉⎾ f g x ⏋{ℰ}
          =: obap.ap( ‼〈unary〉⎾ f ⏋{ℰ}, ‼〈ae-form〉⎾ g x ⏋{ℰ} )
          =: obap.ap( ‼〈function-form〉⎾ f ⏋{ℰ}, ‼〈ae-form〉⎾ g x ⏋{ℰ} )
          =: obap.ap( ‼〈term〉⎾ f ⏋{ℰ}, ‼〈ae-form〉⎾ g x ⏋{ℰ} )
          =: obap.ap( f, ‼〈ae-form〉⎾ g x ⏋{ℰ} )
          =: obap.ap( f, obap.ap(‼〈unary〉⎾ g ⏋{ℰ}, ‼〈ae-form〉⎾ x ⏋{ℰ} ) )
          =: obap.ap( f, obap.ap( g, x) )

    where lindies such as Ʃ'f', Ʃ'g', and Ʃ'x' are written as f, g, and x
          without ambiguity in these cases.

    We can also work out that

      ‼〈ob-exp〉⎾ f g x ⏋{ℰ} :=: ‼〈ob-exp〉⎾ f (g x) ⏋{ℰ}

    signifying that the interpretations are the same (i.e., equivalent),
    keeping in mind that the f, g, and x here are literals and not variables.
    While the equivalence doesn't hold under arbitrary substitutions for f,
    g, and x, the following can be established.

      ‼〈ob-exp〉⎾ 〈unary〉₁ 〈unary〉₂ 〈unary〉₃ ⏋{ℰ}
          :=: ‼〈ob-exp〉⎾ 〈unary〉₁ ( 〈unary〉₂ 〈unary〉₃ ) ⏋{ℰ}

    with the subscripts used to distinguish among 〈unary〉 occurrences,
    following [Knuth1968].


 3. TEXT, CHARACTERS, SPACING, AND CONCRETE LAYOUT CONSIDERATIONS

    [DETAILS TBD]


 10. REFERENCES

[Backus1958]  Backus, J. W. The syntax and semantics of the proposed
    International Algebraic Language of the Zurich ACM-GAMM Conference.
    Proc. International Conference on Information Processing.  UNESCO (Paris:
    June 1959) pp. 125-132.  Available on the Internet at
    <https://www.softwarepreservation.org/projects/ALGOL/paper/Backus-Syntax_and_Semantics_of_Proposed_IAL.pdf/view>

[Cheatham1964]
    Cheatham, T.E.Jr., Sattley, Kirk.  Syntax-Directed Compiling.
    Proceedings of the April 21-23 1964 Spring Joint Computer Conference
    (AFIPS: April 1964), 31-57.  A general parser (syntax analyzer) for
    context-free languages is described.  What we now refer to as a
    lexical analyser is identified as a recognizer layer.  The analyzer
    method is most easily recognized as a top-down parser with back-
    tracking.  It could even be used to produce all analyses available for
    an ambiguous input.  Refinements of this method that I have explored
    include pruning alternatives when they cannot be possible if the
    input will be valid.  This allows early analysis to be forwarded to
    a generation layer.  There also needs to be some assistance in the
    case of left-recursive generations, usually expedited by transforma-
    tion into tail-iterative forms.

[Chomsky1956]
    Chomsky, Noam.  Three models for the description of languages.  IRE
    Transactions on Information Theory 2, 3, 113-124.
    <https://doi.org/10.1109/TIT.1956.1056813>.  Available on the Internet
    at <https://chomsky.info/wp-content/uploads/195609-.pdf>.
       Seeking a model applicable to natural languages, Chomsky identifies
    finite-state languages (now type 3: regular expressions), phrase-
    structure languages (now type 2: context free), and transformational
    languages, the last having his focus.

[Chomsky1959]
    Chomsky, Noam.  On certain formal properties of grammars.  Information
    and Control 2, 2 (1959), 137-167.
    <https://doi.org/10.1016/S0019-9958(59)90362-6>.
       Here Chomsky's models are formalized more fully, establishing a
    hierarchy from recursively-enumerable (type 0, uninteresting for
    linguistics) and descending into strictly-tighter subsets with
    context-sensitive (type 1), context-free type 2), and finite state
    (type 3).  There is a layer (recursive languages) within type 0 and
    containing type 1, so all of types 1-3 are recursive and hence
    decidable.  These are generative grammars: production of grammatical
    strings is described, not to be confused with notation-borrowing
    schemes for the parsing of such text strings.

[Duncan1967]  Duncan, Fraser G.  Notational abbreviations applied to the
    syntax of ALGOL.  Section AB26.3.5 of ALGOL Bulletin 26 (August 1967),
    pp.28-32.  Available on the Internet at
    <http://archive.computerhistory.org/resources/text/algol/algol_bulletin/A26/P35.HTM>.
       This paper made use of nested 〈 ... 〉 in a peculiar way, but it inspired
    me to use it to use productions to generate naming of productions,
    providing a vocabulary grammar and generic arrangements, including moving
    between concrete cases such as 〈integer〉 and 〈〈integer〉-length-string〉.
    This is not needed here.  I just want this reference set to be complete
    wherever I use it.

[Ershov1963]  Ershov, A.P., Kozhukhin, G.I., Voloshin, Yu.M.  The Input
    Language for a System of Automatic Programming.  Computation Center,
    Academy of Sciences of the USSR (Moscow, 1961, Russian); Academic Press
    (London, New York: 1963).
       This provided a type of generic context-free production that inspired
    some of this work, although not relied upon in the ob-exp grammar.

[Gorn1963]
    Gorn, Saul.  Detection of Generative Ambiguities in Context-Free
    Mechanical Languages.  J. ACM 10, 2 (April 1963), 196-208.
    <https://doi.org/10.1145/321160.321168>.
       Section 1, Introduction, offers a precise definition of context-
    free (mechanical) languages along with important considerations such
    as their decidability.  Although it is undecidable, in general,
    whether a given context-free grammar is ambiguous, it is possible to
    determine when a particular statement is by relying on a parser such
    as that of [Cheatham1964].

[Knuth1968]  Knuth, Donald E. Semantics of Context-Free Languages.
    Mathematical Systems Theory 2 (1968), 127-145.  Errata Mathematical
    Systems Theory 5 (1971), 95-96.
       The semantic interpretations here are similar to use of attribute
    grammars except that the arrangement remains context-free and cycles are
    generally not possible.  In the oFrugal application, all well-formed
    inputs have semantics and there are no forward references.  In particular,
    binding names are always references to the nearest preceding bindings,
    if any, and the absence of a preceding binding is semantically acceptable.

[Naur1963]
    Naur, Peter (ed.)., Backus, J.W., Bauer, F.L., Green, J., Katz, C.,
    McCarthy, J., Perlis, A.J., Rutishauser, H., Samelson, K., Vauquois,
    B., Wegstein, J.H., Van Winjgaarden, A., Woodger, M.  Revised Report
    on the Algorithmic Language ALGOL 60.  Comm. ACM 6, 1 (January 1963),
    1-17. DOI <https://doi.org/10.1145/366193.366201>.
       Although the 1960 publication is often cited, corrections were
    called for, leading the the 1963 Revised Report.  Some ambiguities
    in the grammar were repaired.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

                 Copyright 2018-2022 Dennis E. Hamilton

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  ATTRIBUTION

   Hamilton, Dennis E. Formal Grammars and Interpretations for oMiser.  Miser
   Theory text file grammars.txt version 0.0.1 dated 2022-08-12,
   available on the Internet as a version of
   <https://github.com/orcmid/miser/blob/master/oFrugal/grammars.txt>

TODO

 * Prune these TODOs to remove thoe that apply to oFrugalese, ob-exp, or
   other topics.

 * Revealing examples are needed here.  Grace Hopper favored that and I
   should heed it for that reason alone.

 * Cite other forms of BNF, such as the EBNF used at IETF, others.

 * Cite the Ned Irons paper on syntax-directed compiling for its historical
   importance.

 * Add the handling of concrete cases and the tie-in to a reference
   character code, akin to the counterpart in the XML specification.

 * Use the XML 1.0 (Namespaces) characterization of white space, letters,
   digits, and the restricted allowance of other characters in ob-exp terms.
   Provide a reference.

 * It is necessary to make clear that these are geneative grammars and there
   should be some links about those.  The Saul Gorn clarity would be useful.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 0.0.1  2022-08-12T18:42Z Cleanups and TODO management
 0.0.0  2022-08-11T17:36Z Place-holder and boiler-plate extracted from
        ob-exp.txt 1.0.1 and mindelay.txt


                 *** end of oFrugal/grammars.txt ***
